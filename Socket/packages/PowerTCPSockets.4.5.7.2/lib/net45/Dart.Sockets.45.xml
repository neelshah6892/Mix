<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Dart.Sockets.45</name>
    </assembly>
    <members>
        <member name="T:Dart.Sockets.ComponentBase">
            <summary>
            Base class for PowerTCP Components.
            </summary>
        </member>
        <member name="M:Dart.Sockets.ComponentBase.Deserialize(System.IO.Stream)">
            <summary>
            Deserialize a previously serialized object.
            </summary>
            <param name="serializedObject">A stream containing the serialized data to deserialize.</param>
            <returns>The deserialized object.</returns>
            <remarks>
            Provides a simple mechanism for restoring a previously serialized state.
            For example, the state (all runtime parameters) of a Session object could be saved.
            The provided serializedObject is read from its current position.
            </remarks>
        </member>
        <member name="M:Dart.Sockets.ComponentBase.Serialize(System.Object,System.IO.Stream)">
            <summary> 
            Serialize an object to the provided destination stream.
            </summary>
            <param name="objectToSerialize">Object to serialize.</param>
            <param name="destination">Stream destination for the serialized data.</param>
            <remarks>
            Can be used at runtime to persist the state of an object.
            For example, all runtime parameters of a Session object could be saved.
            </remarks>
        </member>
        <member name="M:Dart.Sockets.ComponentBase.Marshal(System.String,System.Object)">
            <summary>
            Marshals a string and/or object to the UI thread and raises the UserState event.
            </summary>
            <param name="message">Message to pass into the UserState event.</param>
            <param name="state">Object to pass to the UserState event; can be null.</param>
            <remarks>
                <para>
                Used to marshal a string and/or object from a worker thread to the UI thread 
                for typical display purposes. 
                It calls <see cref="M:Dart.Sockets.ComponentBase.OnUserState(Dart.Sockets.UserStateEventArgs)" />, which raises the <see cref="E:Dart.Sockets.ComponentBase.UserState" /> event.
                </para>
                <para>
                See the <see cref="P:Dart.Sockets.ComponentBase.SynchronizingObject">SynchronizingObject</see> property for information on 
                updating UI controls in your event handler.
                Internally, SynchronizingObject.BeginInvoke is used to marshal data when the SynchronizingObject is not null, and
                Delegate.DynamicInvoke is used when SynchronizingObject is null.  
                This method is provided for convenience; the developer may use alternative methods for marshaling data as required.
                </para>
            </remarks>
        </member>
        <member name="M:Dart.Sockets.ComponentBase.Marshal(System.Exception)">
            <summary>
            Marshals an exception to the UI thread and raises the Error event.
            </summary>
            <param name="exception">The Exception to be marshaled.</param>
            <remarks>
                <para>
                Used to marshal exceptions from a worker thread to the UI thread for typical display purposes.  
                It calls <see cref="M:Dart.Sockets.ComponentBase.OnError(Dart.Sockets.ErrorEventArgs)" />, which raises the <see cref="E:Dart.Sockets.ComponentBase.Error" /> event.
                </para>
                <para>
                When Start is used, unhandled exceptions generated on worker threads are marshaled to the UI thread
                by this method.
                </para>
                <para>
                See the <see cref="P:Dart.Sockets.ComponentBase.SynchronizingObject">SynchronizingObject</see> property for information on 
                updating UI controls in your event handler.
                Internally, SynchronizingObject.BeginInvoke is used to marshal data when the SynchronizingObject is not null, and
                Delegate.DynamicInvoke is used when SynchronizingObject is null.   
                This method is provided for convenience; the developer may use alternative methods for marshaling data as required.
                </para>
            </remarks>
        </member>
        <member name="M:Dart.Sockets.ComponentBase.OnUserState(Dart.Sockets.UserStateEventArgs)">
            <summary>
            Raises the <see cref="E:Dart.Sockets.ComponentBase.UserState" /> event.
            </summary>
            <param name="e">A <see cref="T:Dart.Sockets.UserStateEventArgs" /> object that contains the user information.</param>
            <remarks>
            If the Synchronizing property is set, this method invokes <see cref="E:Dart.Sockets.ComponentBase.UserState" /> asynchronously on the UI thread.
            If the Synchronizing property is null, this method invokes UserState on the executing thread.
            <para>
            OnUserState allows derived classes to handle the event without attaching a delegate. 
            This is the preferred technique for handling the event in a derived class, but marshaling is not provided.
            </para><para><b>Note to Inheritors:</b> When overriding OnUserState in a derived class, 
            be sure to call the base class OnUserState method, so that registered delegates receive the event. 
            </para><para>
            See the <see cref="P:Dart.Sockets.ComponentBase.SynchronizingObject">SynchronizingObject</see> property for information on 
            updating UI controls in your event handler.
            </para></remarks>
        </member>
        <member name="M:Dart.Sockets.ComponentBase.OnError(Dart.Sockets.ErrorEventArgs)">
            <summary>
            Raises the <see cref="E:Dart.Sockets.ComponentBase.Error" /> event.
            </summary>
            <param name="e">A <see cref="T:Dart.Sockets.ErrorEventArgs" /> object that contains the exception.</param>
            <remarks>
            If the Synchronizing property is set, this method invokes <see cref="E:Dart.Sockets.ComponentBase.Error" /> asynchronously on the UI thread.
            If the Synchronizing property is null, this method invokes the Error event on the executing thread.
            <para>
            OnError allows derived classes to handle the Error event without attaching a delegate, but marshaling is not provided.
            This is the preferred technique for handling the event in a derived class.
            </para><para><b>Note to Inheritors:</b> When overriding OnError in a derived class, 
            be sure to call the base class OnError method, so that registered delegates receive the event. 
            </para><para>
            See the <see cref="P:Dart.Sockets.ComponentBase.SynchronizingObject">SynchronizingObject</see> property for information on 
            updating UI controls in your event handler.
            </para></remarks>
        </member>
        <member name="P:Dart.Sockets.ComponentBase.SynchronizingObject">
            <summary>
            Gets or sets the object used to marshal data to the UI thread (for raising events). 
            </summary>
            <remarks>
                <para>
                This property determines the thread on which the component's event handlers are raised. If set
                to a UI control, events are raised on the UI thread. If null, events are raised on the current thread.
                </para>
                <para>
                This property is automatically set to the containing control when used in the Windows Forms designer. 
                When a derived class is dynamically created this property must be set if marshaling
                to the UI thread is desired.
                </para>
            </remarks>
        </member>
        <member name="P:Dart.Sockets.ComponentBase.SyncRoot">
            <summary>
            Gets an object that is used to synchronize access to the upper layer protocol in use.
            </summary>
            <remarks>
            Upper layer protocols typically send a command and wait for it to complete. Use of this object in a C# "lock" statement
            can allow your code to wait until any ongoing command has completed.
            </remarks>
        </member>
        <member name="E:Dart.Sockets.ComponentBase.UserState">
            <summary>
            Raised when <see cref="M:Dart.Sockets.ComponentBase.Marshal(System.String,System.Object)" /> is used.
            </summary>
            <remarks>
                See the <see cref="P:Dart.Sockets.ComponentBase.SynchronizingObject">SynchronizingObject</see> property for information on 
                updating UI controls in your event handler.
            </remarks>
        </member>
        <member name="E:Dart.Sockets.ComponentBase.Error">
            <summary>
            Raised when <see cref="M:Dart.Sockets.ComponentBase.Marshal(System.Exception)" /> is used or an unhandled Exception is thrown in a worker thread created using Start.
            </summary>
            <remarks>
                See the <see cref="P:Dart.Sockets.ComponentBase.SynchronizingObject">SynchronizingObject</see> property for information on 
                updating UI controls in your event handler.
            </remarks>
        </member>
        <member name="P:Dart.Sockets.ComponentBase.Encoding">
            <summary>
            Character encoding used by the component.
            </summary>
        </member>
        <member name="P:Dart.Sockets.ComponentBase.Tag">
            <summary>
            Gets or sets an object that stores any user data.
            </summary>
        </member>
        <member name="T:Dart.Sockets.UserStateEventArgs">
            <summary>
            Provides data for <see cref="E:Dart.Sockets.ComponentBase.UserState" />.
            Base class for EventArgs that have <see cref="P:Dart.Sockets.UserStateEventArgs.Message" /> and <see cref="P:Dart.Sockets.UserStateEventArgs.UserState" /> properties.
            </summary>
        </member>
        <member name="M:Dart.Sockets.UserStateEventArgs.#ctor(System.String,System.Object)">
            <summary>
            Initializes a new UserStateEventArgs.
            </summary>
        </member>
        <member name="P:Dart.Sockets.UserStateEventArgs.Message">
            <summary>
            Returns the message argument provided by the Marshal method.
            </summary>
        </member>
        <member name="P:Dart.Sockets.UserStateEventArgs.UserState">
            <summary>
            Returns the user state argument provided by the Marshal method.
            </summary>
        </member>
        <member name="T:Dart.Sockets.ErrorEventArgs">
            <summary>
            Provides data for the <see cref="E:Dart.Sockets.ComponentBase.Error">Error</see> event.
            </summary>
        </member>
        <member name="M:Dart.Sockets.ErrorEventArgs.#ctor(System.Exception)">
            <summary>
            Save an exception within this class.
            </summary>
            <param name="exception">Exception to save.</param>
        </member>
        <member name="M:Dart.Sockets.ErrorEventArgs.GetException">
            <summary>
            Returns the Exception marshaled to the UI thread.
            </summary>
            <returns>Exception</returns>
        </member>
        <member name="T:Dart.Sockets.DartLicenseException">
            <summary>
             The base class for all Dart component license exceptions.
             </summary>
            <remarks>
                <para>
             Use the DartLicenseException class to catch runtime licensing exceptions.
             These exceptions are thrown at component creation time and during access of select properties or methods.
             The Message property will provide a description of the specific licensing problem encountered.
             The InnerException property should also be examined for additional details.
             </para>
            </remarks>
        </member>
        <member name="T:Dart.Sockets.DataDirection">
            <summary>
            Enumerates the direction of data flow.
            </summary>
        </member>
        <member name="F:Dart.Sockets.DataDirection.In">
            <summary>
            Data was received (using the Read method).
            </summary>
        </member>
        <member name="F:Dart.Sockets.DataDirection.Out">
            <summary>
            Data was sent (using the Write method).
            </summary>
        </member>
        <member name="T:Dart.Sockets.Data">
            <summary>
            Encapsulates data read or written.
            </summary>
        </member>
        <member name="T:Dart.Sockets.Segment">
            <summary>
            Used to describe a byte[] segment that holds data.
            </summary>
        </member>
        <member name="M:Dart.Sockets.Segment.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Used to create a Segment object that holds a buffer of data.
            </summary>
            <param name="buffer">Byte[] containing data.</param>
            <param name="offset">Offset into the buffer where the data starts.</param>
            <param name="count">Byte count of data.</param>
        </member>
        <member name="P:Dart.Sockets.Segment.Buffer">
            <summary>
            Gets the buffer that holds data.
            </summary>
        </member>
        <member name="P:Dart.Sockets.Segment.Offset">
            <summary>
            The offset into the buffer where the data starts.
            </summary>
        </member>
        <member name="P:Dart.Sockets.Segment.Count">
            <summary>
            Byte count of data.
            </summary>
        </member>
        <member name="M:Dart.Sockets.Data.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates a Data object using the default encoding.
            </summary>
            <param name="buffer">The buffer holding byte data values.</param>
            <param name="offset">The offset bytes where the data starts.</param>
            <param name="count">The number of bytes with data values.</param>
        </member>
        <member name="M:Dart.Sockets.Data.#ctor(System.Byte[],System.Int32,System.Int32,System.Text.Encoding)">
            <summary>
            Creates a Data object using the specified encoding.
            </summary>
            <param name="buffer">The buffer holding byte data values.</param>
            <param name="offset">The offset bytes where the data starts.</param>
            <param name="count">The number of bytes with data values.</param>
            <param name="encoding">The encoding type to use.</param>
        </member>
        <member name="M:Dart.Sockets.Data.ToString">
            <summary>
            Gets the data as a decoded string.
            </summary>
            <returns>The <see cref="T:System.Buffer" /> decoded into a string using <see cref="P:Dart.Sockets.Data.Encoding" />.</returns>
        </member>
        <member name="P:Dart.Sockets.Data.Direction">
            <summary>
            Indicates whether data is inbound or outbound.
            </summary>
        </member>
        <member name="P:Dart.Sockets.Data.Encoding">
            <summary>
            Gets the character encoding used by the object.
            </summary>
        </member>
        <member name="P:Dart.Sockets.Data.Delimiter">
            <summary>
            Gets the delimiter byte array used by <see cref="M:Dart.Sockets.TcpBase.ReadToDelimiter(System.Byte[])" />.
            </summary>
            <value>Null if no delimiter was used or no delimiter was found. Otherwise, the delimiter byte array.</value>
        </member>
        <member name="T:Dart.Sockets.BaseEventArgs">
            <summary>
            Base class for event arguments.
            </summary>
        </member>
        <member name="T:Dart.Sockets.ConnectionState">
            <summary>
            Enumerates the possible values of the connection state.
            </summary>
        </member>
        <member name="F:Dart.Sockets.ConnectionState.Closed">
            <summary>
            The connection is closed.
            </summary>
        </member>
        <member name="F:Dart.Sockets.ConnectionState.Connected">
            <summary>
            The TCP connection is established but not secure.
            </summary>
        </member>
        <member name="F:Dart.Sockets.ConnectionState.ConnectedAndSecure">
            <summary>
            The connection is connected and secure.
            </summary>
        </member>
        <member name="T:Dart.Sockets.DataEventArgs">
            <summary>
            Provides data for reporting events.
            </summary>
        </member>
        <member name="M:Dart.Sockets.DataEventArgs.#ctor(Dart.Sockets.Data,System.String,System.Object)">
            <summary>
            Initialize a new DataEventArgs.
            </summary>
        </member>
        <member name="M:Dart.Sockets.DataEventArgs.ToString">
            <summary>
            Gets the Data property as a decoded string.
            </summary>
            <returns>The Data.Buffer decoded into a string using the Data.Encoding specified.</returns>
        </member>
        <member name="P:Dart.Sockets.DataEventArgs.Data">
            <summary>
            Gets data provided by Data and Log events.
            </summary>
        </member>
        <member name="T:Dart.Sockets.Datagram">
            <summary>
            Encapsulates a datagram read into a buffer.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Datagram.Origin">
            <summary>
            The origin of the datagram sent or received.
            </summary>
        </member>
        <member name="T:PowerTcp">
            <summary>
            Summary
            </summary>
        </member>
        <member name="M:PowerTcp.#ctor">
            <summary>
            Summary
            </summary>
        </member>
        <member name="T:Dart.Sockets.PtyBase">
            <summary>
            This class provides support for interactive on-line terminal access using controls derived from TextBoxBase.
            </summary>
        </member>
        <member name="T:Dart.Sockets.TcpBase">
            <summary>
            Base class for components utilizing protocols built upon the TCP protocol.
            </summary>
        </member>
        <member name="T:Dart.Sockets.SocketBase">
            <summary>
            Base class for PowerTCP Components.
            </summary>
        </member>
        <member name="M:Dart.Sockets.SocketBase.Dispose(System.Boolean)">
            <summary>
            Disposes of SocketBase and its associated resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="P:Dart.Sockets.SocketBase.Socket">
            <summary>
            Gets the socket used by the component for communications.
            </summary>
            <value>The <see cref="T:System.Net.Sockets.Socket">Socket</see> used for UDP or TCP communications. Returns null when not in use.</value>
        </member>
        <member name="M:Dart.Sockets.TcpBase.Marshal(Dart.Sockets.Data,System.String,System.Object)">
            <summary>
            Marshals data to the UI thread. 
            </summary>
            <param name="data">
                <see cref="E:Dart.Sockets.TcpBase.Data" /> to be marshaled.</param>
            <param name="message">Text message to be marshaled.</param>
            <param name="state">State information to be marshaled.</param>
            <remarks>
                <para>
                This method is used to marshal data from a worker thread to the UI thread for typical display purposes. 
                It calls the <see cref="M:Dart.Sockets.TcpBase.OnData(Dart.Sockets.DataEventArgs)" /> method, which raises the <see cref="E:Dart.Sockets.TcpBase.Data" /> event.
                </para>
                <para>
                See the <see cref="P:Dart.Sockets.ComponentBase.SynchronizingObject">SynchronizingObject</see> property for information on 
                updating UI controls in your event handler.
                </para>
            </remarks>
            <example>
        This example demonstrates execution of a looping Read on a worker thread, and marshaling the data to the UI.
        <code lang="C#">
        private void button1_Click(object sender, EventArgs e)
        {
            myComponent.Start(readLoopWorker, null);
        }

        private void readLoopWorker(object state)
        {
            byte[] buffer = new byte[1024];
            Data data = myComponent.Read(buffer);
            while (data != null)
            {
                myComponent.Marshal(data, "", null);
                data = myComponent.Read(buffer);
            }
            myComponent.Close();
        }

        void myComponent_Data(object sender, Dart.Sockets.DataEventArgs e)
        {
            textBox1.AppendText(e.Data.ToString());
        }
        </code><code lang="VB">
        Private Sub button1_Click(ByVal sender As Object, ByVal e As EventArgs)
            myComponent.Start(AddressOf readLoopWorker, Nothing)
        End Sub

        Private Sub readLoopWorker(ByVal state As Object)
            Dim buffer(1023) As Byte
            Dim data As Data = myComponent.Read(buffer)
            Do While data IsNot Nothing
                myComponent.Marshal(data, "", Nothing)
                data = myComponent.Read(buffer)
            Loop
            myComponent.Close()
        End Sub

        Private Sub myComponent_Data(ByVal sender As Object, ByVal e As Dart.Sockets.DataEventArgs)
            textBox1.AppendText(e.Data.ToString())
        End Sub
        </code></example>
        </member>
        <member name="M:Dart.Sockets.TcpBase.OnData(Dart.Sockets.DataEventArgs)">
            <summary>
            Raises the <see cref="E:Dart.Sockets.TcpBase.Data" /> event.
            </summary>
            <param name="e">A <see cref="T:Dart.Sockets.DataEventArgs">DataEventArgs</see> object that contains the event data.</param>
            <remarks>
            If the Synchronizing property is set, this method synchronously invokes the <see cref="E:Dart.Sockets.TcpBase.Data" /> event on the UI thread.
            If the Synchronizing property is null, this method invokes the event on the executing thread.
            <para>
            The OnData method allows derived classes to handle the event without attaching a delegate, but marshaling is not provided.
            This is the preferred technique for handling the event in a derived class.
            </para><para><b>Note to Inheritors:</b> When overriding OnData in a derived class, 
            be sure to call the base class OnData method, so that registered delegates receive the event. 
            </para><para>
            See the <see cref="P:Dart.Sockets.ComponentBase.SynchronizingObject">SynchronizingObject</see> property for information on 
            updating UI controls in your event handler.
            </para></remarks>
        </member>
        <member name="M:Dart.Sockets.TcpBase.OnStateChanged(System.EventArgs)">
            <summary>
            Raises the <see cref="E:Dart.Sockets.TcpBase.StateChanged" /> event.
            </summary>
            <param name="e">An <see cref="T:System.EventArgs">EventArgs</see>.</param>
            <remarks>
            If the Synchronizing property is set, this method synchronously invokes the event on the UI thread.
            If the Synchronizing property is null, this method invokes the event on the executing thread.
            <para>
            The OnStateChanged method allows derived classes to handle the event without attaching a delegate, but marshaling is not provided.
            This is the preferred technique for handling the event in a derived class.
            </para><para><b>Note to Inheritors:</b> When overriding OnStateChanged in a derived class, 
            be sure to call the base class OnStateChanged method, so that registered delegates receive the event. 
            </para><para>
            See the <see cref="P:Dart.Sockets.ComponentBase.SynchronizingObject">SynchronizingObject</see> property for information on 
            updating UI controls in your event handler.
            </para></remarks>
        </member>
        <member name="M:Dart.Sockets.TcpBase.OnLog(Dart.Sockets.DataEventArgs)">
            <summary>
            Raises the <see cref="E:Dart.Sockets.TcpBase.Log" /> event.
            </summary>
            <param name="e">A <see cref="T:Dart.Sockets.DataEventArgs" /> object containing data to log.</param>
            <remarks>
                <para>
            If the Synchronizing property is set, this method asynchronously invokes the event on the UI thread.
            If the Synchronizing property is null, this method invokes the event on the executing thread.
            </para>
                <para>
            The OnLog method allows derived classes to handle the event without attaching a delegate, but marshaling is not provided.
            This is the preferred technique for handling the event in a derived class.
            </para>
                <para>
                    <b>Note to Inheritors:</b> When overriding OnLog in a derived class, 
            be sure to call the base class OnLog method, so that registered delegates receive the event. 
            </para>
                <para>
            See the <see cref="P:Dart.Sockets.ComponentBase.SynchronizingObject">SynchronizingObject</see> property for information on 
            updating UI controls in your event handler.
            </para>
            </remarks>
        </member>
        <member name="M:Dart.Sockets.TcpBase.AuthenticateAsClient(Dart.Sockets.ClientSecurity)">
            <summary>
            Authenticates the server when establishing a secure connection.
            </summary>
            <param name="security">Security parameters used during authentication.</param>
            <remarks>
                <para>
            The security.TargetHost should match the server certificate name. If authentication fails, an <see cref="T:System.Security.Authentication.AuthenticationException">AuthenticationException</see> will occur.
            </para>
                <para>
            To accept or reject a certificate "on-the-fly" implement a <see cref="F:Dart.Sockets.Security.ValidationCallback">ClientSecurity.ValidationCallback</see> function.
            </para>
                <para>
            To select a client certificate "on-the-fly" implement a <see cref="F:Dart.Sockets.ClientSecurity.SelectionCallback">ClientSecurity.SelectionCallback</see> function.
            </para>
            </remarks>
        </member>
        <member name="M:Dart.Sockets.TcpBase.AuthenticateAsClient(Dart.Sockets.TcpSession)">
            <summary>
            Authenticates the server when establishing a secure connection.
            </summary>
            <param name="session">Session parameters used during authentication.</param>
            <remarks>
                <para>
            Uses <see cref="P:Dart.Sockets.Session.RemoteEndPoint" />, <see cref="P:Dart.Sockets.TcpSession.Proxy" /> and <see cref="P:Dart.Sockets.TcpSession.Security" /> to specify
            <see cref="F:Dart.Sockets.Security.ValidationCallback" />, <see cref="F:Dart.Sockets.ClientSecurity.SelectionCallback" />, <see cref="P:Dart.Sockets.ClientSecurity.TargetHost" />,
            <see cref="P:Dart.Sockets.ClientSecurity.Certificates" />, <see cref="P:Dart.Sockets.Security.Protocols" />, and <see cref="P:Dart.Sockets.Security.CheckCertificateRevocation" />.
            </para>
                <para>If session.Security.TargetHost is not specified, then session.RemoteEndPoint.HostNameOrAddress will be used instead.
            session.Security.TargetHost should match the server certificate name. If authentication fails, an <see cref="T:System.Security.Authentication.AuthenticationException">AuthenticationException</see> will occur.
            </para>
                <para>
            To accept or reject a certificate "on-the-fly" implement a <see cref="F:Dart.Sockets.Security.ValidationCallback">TcpSession.Security.ValidationCallback</see> function.
            </para>
                <para>
            To select a client certificate "on-the-fly" implement a <see cref="F:Dart.Sockets.ClientSecurity.SelectionCallback">TcpSession.Security.SelectionCallback</see> function.
            </para>
            </remarks>
            <example>
        This example demonstrates the AuthenticateAsClient call, the callback that prompts for a local certificate, and the callback that executes when a certificate is received.
        <code lang="C#">
        using System.Net.Security;
        using System.Security.Authentication;
        using System.Security.Cryptography.X509Certificates;

        /// &lt;summary&gt;
        /// Establishes SSL with the provided Tcp object. Typically called immediately after connecting to the server (implicit) 
        /// or after a command such as STARTTLS is sent to the server (explicit).
        /// &lt;/summary&gt;
        /// &lt;param name="myComponent"&gt;Object to establish SSL with&lt;/param&gt;
        /// &lt;param name="session"&gt;The TcpSession object used for connecting to the server&lt;/param&gt;
        /// &lt;param name="serverHostName"&gt;The name of the server&lt;/param&gt;
        /// &lt;param name="protocols"&gt;Protocols the client will accept&lt;/param&gt;
        /// &lt;param name="checkRevocation"&gt;Check certificate revocation list during authentication&lt;/param&gt;
        private void authenticateTcp(Tcp myComponent, TcpSession session, string serverHostName, SslProtocols protocols, bool checkRevocation)
        {
            //Specify configuration and certificate callback function, and authenticate server
            //Specifying TargetHost is only necessary if TcpSession.RemoteEndPoint.HostNameOrAddress doesn't match the server's certificate
            session.Security.TargetHost = serverHostName;
            session.Security.Protocols = protocols;
            session.Security.CheckCertificateRevocation = checkRevocation;
            session.Security.ValidationCallback = certificateReceived;
            session.Security.SelectionCallback = selectLocalCertificate;
            myComponent.AuthenticateAsClient(session);
        }

        /// &lt;summary&gt;
        /// Prompts the user to select a certificate for SSL authentication.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// This snippet assumes the presence of the Dart Test Certificate in the user's 'My' certificate store. 
        /// The Dart Test Certificate may be installed from the component's Start Menu program group.
        /// For a UI-based certificate selection, please see the CertificateListForm included with our 
        /// WinForms samples.
        /// &lt;/remarks&gt;
        /// &lt;param name="targetHost"&gt;The host server specified by the client.&lt;/param&gt;
        /// &lt;param name="localCertificates"&gt;A reference to ClientSecurity.Certificates&lt;/param&gt;
        /// &lt;param name="remoteCertificate"&gt;The certificate used to authenticate the remote party.&lt;/param&gt;
        /// &lt;param name="acceptableIssuers"&gt;A String array of certificate issuers acceptable to the remote party.&lt;/param&gt;
        /// &lt;returns&gt;An X509Certificate to use for establishing the SSL connection.&lt;/returns&gt;
        private X509Certificate selectLocalCertificate(Object sender, string targetHost, 
            X509CertificateCollection localCertificates, X509Certificate remoteCertificate, string[] acceptableIssuers)
        {
            //Try to find the Dart Test Certificate
            X509Store certificateStore = new X509Store(StoreName.My);
            certificateStore.Open(OpenFlags.ReadOnly);
            foreach (X509Certificate2 cert in certificateStore.Certificates)
                if (cert.GetNameInfo(X509NameType.SimpleName, true) == "DartdomCA")
                {
                    certificateStore.Close();
                    return cert;
                }
            //Certificate not found, return null
            return null;
        }

        /// &lt;summary&gt;
        /// Presents the server's certificate for validation.
        /// &lt;/summary&gt;
        /// &lt;param name="certificate"&gt;The certificate presented by the server&lt;/param&gt;
        /// &lt;param name="chain"&gt;The chain of certificate authorities associated with the remote certificate&lt;/param&gt;
        /// &lt;param name="sslPolicyErrors"&gt;One or more errors associated with the server's certificate&lt;/param&gt;
        /// &lt;returns&gt;A Boolean value that specifies whether the presented certificate is accepted for authentication&lt;/returns&gt;
        private bool certificateReceived(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
        {
            //Accept certificate if it passed standard validation.
            if (sslPolicyErrors == SslPolicyErrors.None)
                return true;

            string msg = "The server could not be validated for the following reason(s):";

            if ((sslPolicyErrors &amp; SslPolicyErrors.RemoteCertificateNotAvailable) == SslPolicyErrors.RemoteCertificateNotAvailable)
                msg += Environment.NewLine + "    -The server did not present a certificate.";
            else
            {
                if ((sslPolicyErrors &amp; SslPolicyErrors.RemoteCertificateNameMismatch) == SslPolicyErrors.RemoteCertificateNameMismatch)
                    msg += Environment.NewLine + "    -Certificate name mismatch.";
                if ((sslPolicyErrors &amp; SslPolicyErrors.RemoteCertificateChainErrors) == SslPolicyErrors.RemoteCertificateChainErrors)
                {
                    msg += Environment.NewLine + "    -Certificate chain errors:" + Environment.NewLine;

                    foreach (X509ChainStatus item in chain.ChainStatus)
                        msg += "    --" + item.StatusInformation;
                }
            }

            //Prompt to override security check
            msg += Environment.NewLine + "Override security check?";
            if (MessageBox.Show(msg, "Security Alert: Server could not be validated", MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation) == DialogResult.Yes)
                return true;
            else
                return false;
        }
        </code><code lang="VB">
        Imports System.Net.Security
        Imports System.Security.Authentication
        Imports System.Security.Cryptography.X509Certificates

        ''' &lt;summary&gt;
        ''' Establishes SSL with the provided Tcp object. Typically called immediately after connecting to the server (implicit) 
        ''' or after a command such as STARTTLS is sent to the server (explicit).
        ''' &lt;/summary&gt;
        ''' &lt;param name="myComponent"&gt;Object to establish SSL with&lt;/param&gt;
        ''' &lt;param name="session"&gt;The TcpSession object used for connecting to the server&lt;/param&gt;
        ''' &lt;param name="serverHostName"&gt;The name of the server&lt;/param&gt;
        ''' &lt;param name="protocols"&gt;Protocols the client will accept&lt;/param&gt;
        ''' &lt;param name="checkRevocation"&gt;Check certificate revocation list during authentication&lt;/param&gt;
        Private Sub authenticateTcp(ByVal myComponent As Tcp, ByVal session As TcpSession, ByVal serverHostName As String, ByVal protocols As SslProtocols, ByVal checkRevocation As Boolean)
            'Specify configuration and certificate callback function, and authenticate server
            'Specifying TargetHost is only necessary if TcpSession.RemoteEndPoint.HostNameOrAddress doesn't match the server's certificate
            session.Security.TargetHost = serverHostName
            session.Security.Protocols = protocols
            session.Security.CheckCertificateRevocation = checkRevocation
            session.Security.ValidationCallback = AddressOf certificateReceived
            session.Security.SelectionCallback = AddressOf selectLocalCertificate
            myComponent.AuthenticateAsClient(session)
        End Sub

        ''' &lt;summary&gt;
        ''' Prompts the user to select a certificate for SSL authentication.
        ''' &lt;/summary&gt;
        ''' &lt;remarks&gt;
        ''' This snippet assumes the presence of the Dart Test Certificate in the user's 'My' certificate store. 
        ''' The Dart Test Certificate may be installed from the component's Start Menu program group.
        ''' For a UI-based certificate selection, please see the CertificateListForm included with our 
        ''' WinForms samples.
        ''' &lt;/remarks&gt;
        ''' &lt;param name="targetHost"&gt;The host server specified by the client.&lt;/param&gt;
        ''' &lt;param name="localCertificates"&gt;A reference to ClientSecurity.Certificates&lt;/param&gt;
        ''' &lt;param name="remoteCertificate"&gt;The certificate used to authenticate the remote party.&lt;/param&gt;
        ''' &lt;param name="acceptableIssuers"&gt;A String array of certificate issuers acceptable to the remote party.&lt;/param&gt;
        ''' &lt;returns&gt;An X509Certificate to use for establishing the SSL connection.&lt;/returns&gt;
        Private Function selectLocalCertificate(ByVal sender As Object, ByVal targetHost As String, ByVal localCertificates As X509CertificateCollection, ByVal remoteCertificate As X509Certificate, ByVal acceptableIssuers() As String) As X509Certificate
            'Try to find the Dart Test Certificate
            Dim certificateStore As New X509Store(StoreName.My)
            certificateStore.Open(OpenFlags.ReadOnly)
            For Each cert As X509Certificate2 In certificateStore.Certificates
                If cert.GetNameInfo(X509NameType.SimpleName, True) = "DartdomCA" Then
                    certificateStore.Close()
                    Return cert
                End If
            Next cert
            'Certificate not found, return null
            Return Nothing
        End Function

        ''' &lt;summary&gt;
        ''' Presents the server's certificate for validation.
        ''' &lt;/summary&gt;
        ''' &lt;param name="certificate"&gt;The certificate presented by the server&lt;/param&gt;
        ''' &lt;param name="chain"&gt;The chain of certificate authorities associated with the remote certificate&lt;/param&gt;
        ''' &lt;param name="sslPolicyErrors"&gt;One or more errors associated with the server's certificate&lt;/param&gt;
        ''' &lt;returns&gt;A Boolean value that specifies whether the presented certificate is accepted for authentication&lt;/returns&gt;
        Private Function certificateReceived(ByVal sender As Object, ByVal certificate As X509Certificate, ByVal chain As X509Chain, ByVal sslPolicyErrors As SslPolicyErrors) As Boolean
            'Accept certificate if it passed standard validation.
            If sslPolicyErrors = System.Net.Security.SslPolicyErrors.None Then
                Return True
            End If

            Dim msg As String = "The server could not be validated for the following reason(s):"

            If (sslPolicyErrors And System.Net.Security.SslPolicyErrors.RemoteCertificateNotAvailable) = System.Net.Security.SslPolicyErrors.RemoteCertificateNotAvailable Then
                msg &amp;= Environment.NewLine &amp; "    -The server did not present a certificate."
            Else
                If (sslPolicyErrors And System.Net.Security.SslPolicyErrors.RemoteCertificateNameMismatch) = System.Net.Security.SslPolicyErrors.RemoteCertificateNameMismatch Then
                    msg &amp;= Environment.NewLine &amp; "    -Certificate name mismatch."
                End If
                If (sslPolicyErrors And System.Net.Security.SslPolicyErrors.RemoteCertificateChainErrors) = System.Net.Security.SslPolicyErrors.RemoteCertificateChainErrors Then
                    msg &amp;= Environment.NewLine &amp; "    -Certificate chain errors:" &amp; Environment.NewLine

                    For Each item As X509ChainStatus In chain.ChainStatus
                        msg &amp;= "    --" &amp; item.StatusInformation
                    Next item
                End If
            End If

            'Prompt to override security check
            msg &amp;= Environment.NewLine &amp; "Override security check?"
            If MessageBox.Show(msg, "Security Alert: Server could not be validated", MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation) = System.Windows.Forms.DialogResult.Yes Then
                Return True
            Else
                Return False
            End If
        End Function
        </code></example>
        </member>
        <member name="M:Dart.Sockets.TcpBase.AuthenticateAsServer(Dart.Sockets.ServerSecurity)">
            <summary>
            Authenticates a client when establishing a secure connection.
            </summary>
            <param name="security">Security parameters used during authentication.</param>
            <remarks>
            To accept or reject a certificate "on-the-fly" implement a <see cref="F:Dart.Sockets.Security.ValidationCallback">Security.ValidationCallback</see> function.
            </remarks>
            <example>
        This example demonstrates AuthenticateAsServer().
        <code lang="C#">
        using System.Net.Security;
        using System.Security.Authentication;
        using System.Security.Cryptography.X509Certificates;

        /// &lt;summary&gt;
        /// Object containing server security configuration
        /// &lt;/summary&gt;
        ServerSecurity security = new ServerSecurity();

        /// &lt;summary&gt;
        /// Starts the server listening on port 7. server1_NewConnection will 
        /// be invoked on an IO completion thread as each clients connects.
        /// &lt;/summary&gt;
        private void button1_Click(object sender, EventArgs e)
        {
            //Select certificate and set client certificate validation callback
            ConfigSecurity();

            //Start the echo server on port 7
            server1.Start(server1_NewConnection, 7, null);
        }

        /// &lt;summary&gt;
        /// Finds and loads the certificate used for authenticating the server, and sets the ValidationCallback.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// This snippet assumes the presence of the Dart Test Certificate in the user's 'My' certificate store. 
        /// The Dart Test Certificate may be installed from the component's Start Menu program group.
        /// &lt;/remarks&gt;
        private void ConfigSecurity()
        {
            //Try to find the Dart Test Certificate
            X509Store certificateStore = new X509Store(StoreName.My);
            certificateStore.Open(OpenFlags.ReadOnly);
            foreach (X509Certificate2 cert in certificateStore.Certificates)
                if (cert.GetNameInfo(X509NameType.SimpleName, true) == "DartdomCA")
                {
                    security.Certificate = cert;
                    break;
                }
            certificateStore.Close();

            security.ValidationCallback = ClientCertificateValidation;
        }

        /// &lt;summary&gt;
        /// Invoked on an IO completion thread as each client connects.
        /// &lt;/summary&gt;
        /// &lt;param name="client"&gt;The connection to the client&lt;/param&gt;
        /// &lt;param name="state"&gt;Used to pass in data from the 'state' parameter of Server.Start(). Not used in this snippet.&lt;/param&gt;
        private void server1_NewConnection(Tcp client, object state)
        {
            //Establish SSL immediately after client connects. This is commonly known as implicit SSL.
            try
            {
                client.AuthenticateAsServer(security);
            }
            catch (Exception ex)
            {
                //If an error is encountered, disconnect the client. Otherwise the connection will remain open.
                client.Close();
                //Rethrow exception to be automatically marshaled to server1_Error event (not included in this snippet)
                throw ex;
            }

            //Implement protocol logic here, such as an echo server:
            byte[] buffer = new byte[1024];
            Data data = client.Read(buffer);
            while (data != null)
            {
                client.Write(data.Buffer, data.Offset, data.Count);
                data = client.Read(buffer);
            }
        }

        /// &lt;summary&gt;
        /// Presents the client's certificate for validation.
        /// &lt;/summary&gt;
        /// &lt;param name="certificate"&gt;The certificate presented by the client.&lt;/param&gt;
        /// &lt;param name="chain"&gt;The chain of certificate authorities associated with the remote certificate.&lt;/param&gt;
        /// &lt;param name="sslPolicyErrors"&gt;One or more errors associated with the client's certificate.&lt;/param&gt;
        /// &lt;returns&gt;A Boolean value that specifies whether the provided certificate is accepted for authentication.&lt;/returns&gt;
        private bool ClientCertificateValidation(Object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
        {
            //Accept all clients in this snippet. See the AuthenticateAsClient() snippet for a demonstration of examining sslPolicyErrors.
            return true;
        }
        </code><code lang="VB">
        Imports System.Net.Security
        Imports System.Security.Authentication
        Imports System.Security.Cryptography.X509Certificates

        ''' &lt;summary&gt;
        ''' Object containing server security configuration
        ''' &lt;/summary&gt;
        Private security As New ServerSecurity()

        ''' &lt;summary&gt;
        ''' Starts the server listening on port 7. server1_NewConnection will 
        ''' be invoked on an IO completion thread as each clients connects.
        ''' &lt;/summary&gt;
        Private Sub button1_Click(ByVal sender As Object, ByVal e As EventArgs)
            'Select certificate and set client certificate validation callback
            ConfigSecurity()

            'Start the echo server on port 7
            server1.Start(AddressOf server1_NewConnection, 7, Nothing)
        End Sub

        ''' &lt;summary&gt;
        ''' Finds and loads the certificate used for authenticating the server, and sets the ValidationCallback.
        ''' &lt;/summary&gt;
        ''' &lt;remarks&gt;
        ''' This snippet assumes the presence of the Dart Test Certificate in the user's 'My' certificate store. 
        ''' The Dart Test Certificate may be installed from the component's Start Menu program group.
        ''' &lt;/remarks&gt;
        Private Sub ConfigSecurity()
            'Try to find the Dart Test Certificate
            Dim certificateStore As New X509Store(StoreName.My)
            certificateStore.Open(OpenFlags.ReadOnly)
            For Each cert As X509Certificate2 In certificateStore.Certificates
                If cert.GetNameInfo(X509NameType.SimpleName, True) = "DartdomCA" Then
                    security.Certificate = cert
                    Exit For
                End If
            Next cert
            certificateStore.Close()

            security.ValidationCallback = AddressOf ClientCertificateValidation
        End Sub

        ''' &lt;summary&gt;
        ''' Invoked on an IO completion thread as each client connects.
        ''' &lt;/summary&gt;
        ''' &lt;param name="client"&gt;The connection to the client&lt;/param&gt;
        ''' &lt;param name="state"&gt;Used to pass in data from the 'state' parameter of Server.Start(). Not used in this snippet.&lt;/param&gt;
        Private Sub server1_NewConnection(ByVal client As Tcp, ByVal state As Object)
            'Establish SSL immediately after client connects. This is commonly known as implicit SSL.
            Try
                client.AuthenticateAsServer(security)
            Catch ex As Exception
                'If an error is encountered, disconnect the client. Otherwise the connection will remain open.
                client.Close()
                'Rethrow exception to be automatically marshaled to server1_Error event (not included in this snippet)
                Throw ex
            End Try

            'Implement protocol logic here, such as an echo server:
            Dim buffer(1023) As Byte
            Dim data As Data = client.Read(buffer)
            Do While data IsNot Nothing
                client.Write(data.Buffer, data.Offset, data.Count)
                data = client.Read(buffer)
            Loop
        End Sub

        ''' &lt;summary&gt;
        ''' Presents the client's certificate for validation.
        ''' &lt;/summary&gt;
        ''' &lt;param name="certificate"&gt;The certificate presented by the client.&lt;/param&gt;
        ''' &lt;param name="chain"&gt;The chain of certificate authorities associated with the remote certificate.&lt;/param&gt;
        ''' &lt;param name="sslPolicyErrors"&gt;One or more errors associated with the client's certificate.&lt;/param&gt;
        ''' &lt;returns&gt;A Boolean value that specifies whether the provided certificate is accepted for authentication.&lt;/returns&gt;
        Private Function ClientCertificateValidation(ByVal sender As Object, ByVal certificate As X509Certificate, ByVal chain As X509Chain, ByVal sslPolicyErrors As SslPolicyErrors) As Boolean
            'Accept all clients in this snippet. See the AuthenticateAsClient() snippet for a demonstration of examining sslPolicyErrors.
            Return True
        End Function
        </code></example>
        </member>
        <member name="M:Dart.Sockets.TcpBase.ShutdownSsl">
            <summary>
            Signals the remote host to shutdown the SSL connection.
            </summary>
            <remarks>
                <para>
                This method provides a means for switching a secure connection to a non-secure connection.
                </para>
            </remarks>
        </member>
        <member name="M:Dart.Sockets.TcpBase.Connect(Dart.Sockets.TcpSession)">
            <summary>
            Connect to a server using the configuration specified by <i>session</i>.
            </summary>
            <param name="session">Used to specify the local and remote endpoints, and proxy configuration.</param>
        </member>
        <member name="M:Dart.Sockets.TcpBase.ConnectAsync(Dart.Sockets.TcpSession,Dart.Sockets.TcpAsyncCallback,System.Object)">
            <summary>
            Connect to a server using the configuration specified by <i>session</i>.
            </summary>
            <param name="session">Used to specify the local and remote endpoints, and proxy configuration.</param>
            <param name="callback">A <see cref="T:Dart.Sockets.TcpAsyncCallback" /> delegate referencing the method to invoke on an IO completion thread when the operation completes.</param>
            <param name="state">Object to pass into the callback method when the operation completes; can be null.</param>
        </member>
        <member name="M:Dart.Sockets.TcpBase.Close">
            <summary>
            Gracefully closes the connection.
            </summary>
            <remarks>
                <para>
                This method enters a normal TIME_WAIT state after the connection is closed.
                </para>
            </remarks>
        </member>
        <member name="M:Dart.Sockets.TcpBase.Abort">
            <summary>
            Performs a hard close of the connection.
            </summary>
            <remarks>
                <para>
                This method resets the connection and immediately clears the socket state.
                </para>
            </remarks>
        </member>
        <member name="M:Dart.Sockets.TcpBase.GetStream">
            <summary>
            Provides access to the underlying Stream.
            </summary>
            <returns>The underlying <see cref="T:System.IO.Stream">Stream</see> object used by the component.</returns>
            <remarks>Derived classes can override this method to provide a stream that implements an upper-layer protocol.</remarks>
        </member>
        <member name="M:Dart.Sockets.TcpBase.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Receives data from the remote host.
            </summary>
            <param name="buffer">The byte array used to store the received data.</param>
            <param name="offset">The position in the buffer to store the data.</param>
            <param name="count">The maximum number of bytes to receive.</param>
            <returns>
            A <see cref="E:Dart.Sockets.TcpBase.Data">Data</see> object encapsulating the received data. Returns null if the socket is closed.
            </returns>
            <remarks>
                <para>
            This method performs a single socket read, blocking until at least one byte is read, up to as much 
            data as is available on the socket, <i>count</i> bytes, or <i>buffer</i>.Length, whichever is lowest. 
            A SocketException indicating SocketError.Timeout will not result in the socket being closed; 
            other SocketExceptions are fatal and the socket is automatically closed by the class.
            </para>
                <para>
            The <see cref="P:Dart.Sockets.TcpSocketOption.ReceiveTimeout">ReceiveTimeout</see> property controls how 
            long this method will block before throwing a Timeout exception.
            </para>
            </remarks>
        </member>
        <member name="M:Dart.Sockets.TcpBase.Read(System.Byte[])">
            <summary>
            Receives data from the remote host.
            </summary>
            <param name="buffer">The byte array used to store the received data.</param>
            <returns>
            A <see cref="E:Dart.Sockets.TcpBase.Data">Data</see> object encapsulating the received data. Returns null if the socket is closed.
            </returns>
            <remarks>
                <para>
            This method performs a single socket read, blocking until at least one byte is read, up to as much 
            data as is available on the socket or <i>buffer</i>.Length, whichever is lowest.
            </para>
                <para>
            This method will block until data is available or the <see cref="P:Dart.Sockets.TcpSocketOption.ReceiveTimeout">ReceiveTimeout</see> has expired.
            </para>
            </remarks>
            <example>
        This example demonstrates execution of a looping Read on a worker thread, and marshaling the data to the UI.
        <code lang="C#">
        private void button1_Click(object sender, EventArgs e)
        {
            myComponent.Start(readLoopWorker, null);
        }

        private void readLoopWorker(object state)
        {
            byte[] buffer = new byte[1024];
            Data data = myComponent.Read(buffer);
            while (data != null)
            {
                myComponent.Marshal(data, "", null);
                data = myComponent.Read(buffer);
            }
            myComponent.Close();
        }

        void myComponent_Data(object sender, Dart.Sockets.DataEventArgs e)
        {
            textBox1.AppendText(e.Data.ToString());
        }
        </code><code lang="VB">
        Private Sub button1_Click(ByVal sender As Object, ByVal e As EventArgs)
            myComponent.Start(AddressOf readLoopWorker, Nothing)
        End Sub

        Private Sub readLoopWorker(ByVal state As Object)
            Dim buffer(1023) As Byte
            Dim data As Data = myComponent.Read(buffer)
            Do While data IsNot Nothing
                myComponent.Marshal(data, "", Nothing)
                data = myComponent.Read(buffer)
            Loop
            myComponent.Close()
        End Sub

        Private Sub myComponent_Data(ByVal sender As Object, ByVal e As Dart.Sockets.DataEventArgs)
            textBox1.AppendText(e.Data.ToString())
        End Sub
        </code></example>
        </member>
        <member name="M:Dart.Sockets.TcpBase.ReadToDelimiter(System.String)">
            <summary>
            Read until the delimiter is found, an exception is thrown, or the connection is closed.
            </summary>
            <param name="delimiter">A delimiter to search for.</param>
            <returns>
            A <see cref="E:Dart.Sockets.TcpBase.Data">Data</see> object encapsulating the received data.
            </returns>
            <remarks>
                <para>
            This method blocks until the delimiter is found, an exception is thrown, or the server closes the connection.
            The value of Data.Delimiter is set to the found delimiter, if any.
            </para>
                <para>
            If a DataException is thrown, the <see cref="F:Dart.Sockets.DataException.DataRead" /> property contains
            any data received prior to the exception.
            </para>
            </remarks>
            <exception cref="T:Dart.Sockets.DataException">
            The delimiter was not found. The <see cref="F:Dart.Sockets.DataException.DataRead" /> property contains any data received before the failure occurred.
            </exception>
        </member>
        <member name="M:Dart.Sockets.TcpBase.ReadToDelimiter(System.Byte[])">
            <summary>
            Read until the delimiter is found, an exception is thrown, or the connection is closed.
            </summary>
            <param name="delimiter">The delimiter to search for.</param>
            <returns>
            A <see cref="E:Dart.Sockets.TcpBase.Data">Data</see> object encapsulating the received data.
            </returns>
            <remarks>
                <para>
            This method blocks until the delimiter is found, an exception is thrown, or the server closes the 
            connection. The value of Data.Delimiter is set to the found delimiter, if any.
            </para>
                <para>
            If a DataException is thrown, the  <see cref="F:Dart.Sockets.DataException.DataRead" /> property contains any data 
            received prior to the exception.
            </para>
            </remarks>
            <exception cref="T:Dart.Sockets.DataException">
            The delimiter was not found. The <see cref="F:Dart.Sockets.DataException.DataRead" /> property contains any data 
            received before the failure occurred.
            </exception>
        </member>
        <member name="M:Dart.Sockets.TcpBase.ReadToDelimiter(System.String[])">
            <summary>
            Read until a delimiter is found, an exception is thrown, or the connection is closed.
            </summary>
            <param name="delimiters">An array of delimiters to search for.</param>
            <returns>
                <see cref="E:Dart.Sockets.TcpBase.Data">Data</see> object encapsulating the received data.
            </returns>
            <remarks>
                <para>
            This method blocks until a delimiter is found, an exception is thrown, or the server closes the connection. 
            The value of Data.Delimiter is set to the found delimiter, if any.
            </para>
                <para>
            If a DataException is thrown, the  <see cref="F:Dart.Sockets.DataException.DataRead" /> property contains any data received prior to the exception.
            </para>
            </remarks>
            <exception cref="T:Dart.Sockets.DataException">
            The delimiter was not found. The <see cref="F:Dart.Sockets.DataException.DataRead" /> property contains any data received before the failure occurred.
            </exception>
        </member>
        <member name="M:Dart.Sockets.TcpBase.ReadToDelimiter(System.Collections.Generic.List{System.Byte[]})">
            <summary>
            Read until a delimiter is found, an exception is thrown, or the connection is closed.
            </summary>
            <param name="delimiters">A list of delimiters to search for.</param>
            <returns>
            A <see cref="E:Dart.Sockets.TcpBase.Data">Data</see> object encapsulating the received data.
            </returns>
            <remarks>
                <para>
            This method blocks until a delimiter is found, an exception is thrown, or the server closes the connection. 
            The value of Data.Delimiter is set to the found delimiter, if any.
            </para>
                <para>
            If a DataException is thrown, the  <see cref="F:Dart.Sockets.DataException.DataRead" /> property contains any data received prior to the exception.
            </para>
            </remarks>
            <exception cref="T:Dart.Sockets.DataException">
            The delimiter was not found. The <see cref="F:Dart.Sockets.DataException.DataRead" /> property contains any data received before the failure occurred.
            </exception>
        </member>
        <member name="M:Dart.Sockets.TcpBase.ReadAsync(System.Byte[],System.Int32,System.Int32,Dart.Sockets.TcpAsyncCallback,System.Object)">
            <summary>
            Start an asynchronous read on the socket.
            </summary>
            <param name="buffer">The byte array used to store the received data.</param>
            <param name="offset">The position in the buffer to store the data.</param>
            <param name="count">The maximum number of bytes to receive.</param>
            <param name="callback">A <see cref="T:Dart.Sockets.TcpAsyncCallback" /> delegate referencing the method to invoke on an IO completion thread when the operation completes.</param>
            <param name="state">Object to pass into the callback method when the operation completes; can be null.</param>
            <remarks>
            The TCP component is typically used by making blocking calls on a worker (non-UI) thread. This technique keeps development
            simple as there is no need for saving state information, but does require a dedicated thread for each connection. If a dedicated 
            worker thread for each socket is not scalable enough, such as in server applications, developers can instead use 
            the Async methods which utilize IO completion ports. The Async methods do not require a dedicated worker thread for each connection, 
            and the specified <i>callback</i> is invoked on an IO completion thread when the operation completes. This is the best way to create a 
            high-performance server without using dedicated worker threads.
            </remarks>
            <example>
        The following example demonstrates an echo server using asynchronous read and write methods that utilize IO completion ports.
        <code lang="C#">
        private void button1_Click(object sender, EventArgs e)
        {
            //Start the echo server on port 7
            server1.Start(server1_NewConnection, 7, null);
        }

        private void server1_NewConnection(Tcp client, object state)
        {
            //Read first data sent by client
            byte[] buffer = new byte[1024];
            client.ReadAsync(buffer, 0, buffer.Length, client_ReadAsyncCompleted, null);
        }

        private void client_ReadAsyncCompleted(TcpBase client, Data data, Exception ex, object state)
        {
            //Echo data received back to client.
            //Data is null if client is not connected.
            if (data != null)
                client.WriteAsync(data.Buffer, data.Offset, data.Count, client_WriteAsyncCompleted, null);
        }

        private void client_WriteAsyncCompleted(TcpBase client, Data data, Exception ex, object state)
        {
            //Read for more data.
            client.ReadAsync(data.Buffer, 0, data.Buffer.Length, client_ReadAsyncCompleted, null);
        }
        </code><code lang="VB">
        Private Sub button1_Click(ByVal sender As Object, ByVal e As EventArgs)
            'Start the echo server on port 7
            server1.Start(AddressOf server1_NewConnection, 7, Nothing)
        End Sub

        Private Sub server1_NewConnection(ByVal client As Tcp, ByVal state As Object)
            'Read first data sent by client
            Dim buffer(1023) As Byte
            client.ReadAsync(buffer, 0, buffer.Length, AddressOf client_ReadAsyncCompleted, Nothing)
        End Sub

        Private Sub client_ReadAsyncCompleted(ByVal client As TcpBase, ByVal data As Data, ByVal ex As Exception, ByVal state As Object)
            'Echo data received back to client.
            'Data is null if client is not connected.
            If data IsNot Nothing Then
                client.WriteAsync(data.Buffer, data.Offset, data.Count, AddressOf client_WriteAsyncCompleted, Nothing)
            End If
        End Sub

        Private Sub client_WriteAsyncCompleted(ByVal client As TcpBase, ByVal data As Data, ByVal ex As Exception, ByVal state As Object)
            'Read for more data.
            client.ReadAsync(data.Buffer, 0, data.Buffer.Length, AddressOf client_ReadAsyncCompleted, Nothing)
        End Sub
        </code></example>
        </member>
        <member name="M:Dart.Sockets.TcpBase.ReadToCount(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read until count bytes are read, an exception is thrown, or the connection is closed.
            </summary>
            <param name="buffer">The byte array used to store the received data.</param>
            <param name="offset">The position in the buffer to store the data.</param>
            <param name="count">The number of byte to read.</param>
            <returns>
            A <see cref="E:Dart.Sockets.TcpBase.Data">Data</see> object encapsulating the received data.
            </returns>
            <remarks>
            If a DataException is thrown, the  <see cref="F:Dart.Sockets.DataException.DataRead" /> property contains any data received prior to the exception.
            </remarks>
            <exception cref="T:Dart.Sockets.DataException">
            Count bytes could not be read. The <see cref="F:Dart.Sockets.DataException.DataRead" /> property contains any data received before the failure occurred.
            </exception>
        </member>
        <member name="M:Dart.Sockets.TcpBase.ReadToEnd">
            <summary>
            Read until the connection is closed or an exception is thrown.
            </summary>
            <returns>
            A <see cref="E:Dart.Sockets.TcpBase.Data">Data</see> object encapsulating the received data. Returns null if the socket is closed.
            </returns>
            <remarks>
                <para>
            If a DataException is thrown, the  <see cref="F:Dart.Sockets.DataException.DataRead" /> property contains any data received prior to the exception.
            </para>
            </remarks>
            <exception cref="T:Dart.Sockets.DataException">
            A failure occurred before the normal end of stream was found. The <see cref="F:Dart.Sockets.DataException.DataRead" /> property contains any data 
            received before the failure occurred.
            </exception>
        </member>
        <member name="M:Dart.Sockets.TcpBase.Write(System.Byte[])">
            <summary>
            Sends data to the remote host.
            </summary>
            <param name="buffer">Byte array of data to send.</param>
            <returns>
            A <see cref="E:Dart.Sockets.TcpBase.Data">Data</see> object encapsulating the sent data. Returns null if the socket is closed.
            </returns>
            <remarks>
            This method synchronously sends data to the remote host over an existing connection. It will block until a buffer 
            is available to accept the data or SocketOption.SendTimeout has expired.
            </remarks>
        </member>
        <member name="M:Dart.Sockets.TcpBase.Write(System.String)">
            <summary>
            Sends data to the remote host.
            </summary>
            <param name="data">String of data to send.</param>
            <returns>
            A <see cref="E:Dart.Sockets.TcpBase.Data">Data</see> object encapsulating the sent data. Returns null if the socket is closed.
            </returns>
            <remarks>
            This method synchronously sends data to the remote host over an existing connection. It will block until a buffer is available to accept the data or 
            SocketOption.SendTimeout has expired.
            </remarks>
        </member>
        <member name="M:Dart.Sockets.TcpBase.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sends data to the remote host.
            </summary>
            <param name="buffer">Byte array of data to send.</param>
            <param name="offset">The position in the data buffer at which to begin sending data.</param>
            <param name="count">The number of bytes to send.</param>
            <returns>
            A <see cref="E:Dart.Sockets.TcpBase.Data">Data</see> object encapsulating the sent data. Returns null if the socket is closed.
            </returns>
            <remarks>
            This method synchronously sends data to the remote host over an existing connection. It will block until a buffer is available to accept the data or 
            SocketOption.SendTimeout has expired.
            </remarks>
        </member>
        <member name="M:Dart.Sockets.TcpBase.WriteAsync(System.Byte[],System.Int32,System.Int32,Dart.Sockets.TcpAsyncCallback,System.Object)">
            <summary>
            Start an asynchronous write on the socket.
            </summary>
            <param name="buffer">The byte array containing data to be written.</param>
            <param name="offset">The position in the buffer to start writing data from.</param>
            <param name="count">The number of bytes to write.</param>
            <param name="callback">A <see cref="T:Dart.Sockets.TcpAsyncCallback" /> delegate referencing the method to invoke on an IO completion thread when the operation completes.</param>
            <param name="state">Object to pass into the callback method when the operation completes; can be null.</param>
            <remarks>
            The TCP component is typically used by making blocking calls on a worker (non-UI) thread. This technique keeps development
            simple as there is no need for saving state information, but requires a dedicated thread for each connection. If a dedicated 
            worker thread for each socket is not scalable enough, such as in server applications, developers can use 
            Async methods which utilize IO completion ports. Async methods do not require a dedicated worker thread for each connection, 
            and the specified <i>callback</i> is invoked on an IO completion thread when the operation completes. This is the best way to create a 
            scalable, high-performance server.
            </remarks>
            <example>
        The following example demonstrates an echo server using asynchronous read and write methods that utilize IO completion ports.
        <code lang="C#">
        private void button1_Click(object sender, EventArgs e)
        {
            //Start the echo server on port 7
            server1.Start(server1_NewConnection, 7, null);
        }

        private void server1_NewConnection(Tcp client, object state)
        {
            //Read first data sent by client
            byte[] buffer = new byte[1024];
            client.ReadAsync(buffer, 0, buffer.Length, client_ReadAsyncCompleted, null);
        }

        private void client_ReadAsyncCompleted(TcpBase client, Data data, Exception ex, object state)
        {
            //Echo data received back to client.
            //Data is null if client is not connected.
            if (data != null)
                client.WriteAsync(data.Buffer, data.Offset, data.Count, client_WriteAsyncCompleted, null);
        }

        private void client_WriteAsyncCompleted(TcpBase client, Data data, Exception ex, object state)
        {
            //Read for more data.
            client.ReadAsync(data.Buffer, 0, data.Buffer.Length, client_ReadAsyncCompleted, null);
        }
        </code><code lang="VB">
        Private Sub button1_Click(ByVal sender As Object, ByVal e As EventArgs)
            'Start the echo server on port 7
            server1.Start(AddressOf server1_NewConnection, 7, Nothing)
        End Sub

        Private Sub server1_NewConnection(ByVal client As Tcp, ByVal state As Object)
            'Read first data sent by client
            Dim buffer(1023) As Byte
            client.ReadAsync(buffer, 0, buffer.Length, AddressOf client_ReadAsyncCompleted, Nothing)
        End Sub

        Private Sub client_ReadAsyncCompleted(ByVal client As TcpBase, ByVal data As Data, ByVal ex As Exception, ByVal state As Object)
            'Echo data received back to client.
            'Data is null if client is not connected.
            If data IsNot Nothing Then
                client.WriteAsync(data.Buffer, data.Offset, data.Count, AddressOf client_WriteAsyncCompleted, Nothing)
            End If
        End Sub

        Private Sub client_WriteAsyncCompleted(ByVal client As TcpBase, ByVal data As Data, ByVal ex As Exception, ByVal state As Object)
            'Read for more data.
            client.ReadAsync(data.Buffer, 0, data.Buffer.Length, AddressOf client_ReadAsyncCompleted, Nothing)
        End Sub
        </code></example>
        </member>
        <member name="M:Dart.Sockets.TcpBase.ConnectTaskAsync(Dart.Sockets.TcpSession)">
            <summary>
            Connect to a server using the configuration specified by <i>session</i>.
            </summary>
            <param name="session">Used to specify the local and remote endpoints, and proxy configuration.</param>
            <returns>
            An awaitable task that represents the connect operation.
            </returns>
        </member>
        <member name="M:Dart.Sockets.TcpBase.AuthenticateAsClientTaskAsync(Dart.Sockets.ClientSecurity)">
            <summary>
            Authenticates the server when establishing a secure connection.
            </summary>
            <param name="security">Security parameters used during authentication.</param>
            <returns>
            An awaitable task that represents the authentication operation.
            </returns>
            <remarks>
                <para>
            The security.TargetHost should match the server certificate name. If authentication fails, an <see cref="T:System.Security.Authentication.AuthenticationException">AuthenticationException</see> will occur.
            </para>
                <para>
            To accept or reject a certificate "on-the-fly" implement a <see cref="F:Dart.Sockets.Security.ValidationCallback">ClientSecurity.ValidationCallback</see> function.
            </para>
                <para>
            To select a client certificate "on-the-fly" implement a <see cref="F:Dart.Sockets.ClientSecurity.SelectionCallback">ClientSecurity.SelectionCallback</see> function.
            </para>
            </remarks>
        </member>
        <member name="M:Dart.Sockets.TcpBase.AuthenticateAsClientTaskAsync(Dart.Sockets.TcpSession)">
            <summary>
            Authenticates the server when establishing a secure connection.
            </summary>
            <param name="session">Session parameters used during authentication.</param>
            <remarks>
                <para>
            Uses <see cref="P:Dart.Sockets.Session.RemoteEndPoint" />, <see cref="P:Dart.Sockets.TcpSession.Proxy" /> and <see cref="P:Dart.Sockets.TcpSession.Security" /> to specify
            <see cref="F:Dart.Sockets.Security.ValidationCallback" />, <see cref="F:Dart.Sockets.ClientSecurity.SelectionCallback" />, <see cref="P:Dart.Sockets.ClientSecurity.TargetHost" />,
            <see cref="P:Dart.Sockets.ClientSecurity.Certificates" />, <see cref="P:Dart.Sockets.Security.Protocols" />, and <see cref="P:Dart.Sockets.Security.CheckCertificateRevocation" />.
            </para>
                <para>If session.Security.TargetHost is not specifed, then session.RemoteEndPoint.HostNameOrAddress will be used instead.
            session.Security.TargetHost should match the server certificate name. If authentication fails, an <see cref="T:System.Security.Authentication.AuthenticationException">AuthenticationException</see> will occur.
            </para>
                <para>
            To accept or reject a certificate "on-the-fly" implement a <see cref="F:Dart.Sockets.Security.ValidationCallback">TcpSession.Security.ValidationCallback</see> function.
            </para>
                <para>
            To select a client certificate "on-the-fly" implement a <see cref="F:Dart.Sockets.ClientSecurity.SelectionCallback">TcpSession.Security.SelectionCallback</see> function.
            </para>
            </remarks>
            <example>
        This example demonstrates the AuthenticateAsClient call, the callback that prompts for a local certificate, and the callback that executes when a certificate is received.
        <code lang="C#">
        using System.Net.Security;
        using System.Security.Authentication;
        using System.Security.Cryptography.X509Certificates;

        /// &lt;summary&gt;
        /// Establishes SSL with the provided Tcp object. Typically called immediately after connecting to the server (implicit) 
        /// or after a command such as STARTTLS is sent to the server (explicit).
        /// &lt;/summary&gt;
        /// &lt;param name="myComponent"&gt;Object to establish SSL with&lt;/param&gt;
        /// &lt;param name="session"&gt;The TcpSession object used for connecting to the server&lt;/param&gt;
        /// &lt;param name="serverHostName"&gt;The name of the server&lt;/param&gt;
        /// &lt;param name="protocols"&gt;Protocols the client will accept&lt;/param&gt;
        /// &lt;param name="checkRevocation"&gt;Check certificate revocation list during authentication&lt;/param&gt;
        private void authenticateTcp(Tcp myComponent, TcpSession session, string serverHostName, SslProtocols protocols, bool checkRevocation)
        {
            //Specify configuration and certificate callback function, and authenticate server
            //Specifying TargetHost is only necessary if TcpSession.RemoteEndPoint.HostNameOrAddress doesn't match the server's certificate
            session.Security.TargetHost = serverHostName;
            session.Security.Protocols = protocols;
            session.Security.CheckCertificateRevocation = checkRevocation;
            session.Security.ValidationCallback = certificateReceived;
            session.Security.SelectionCallback = selectLocalCertificate;
            myComponent.AuthenticateAsClient(session);
        }

        /// &lt;summary&gt;
        /// Prompts the user to select a certificate for SSL authentication.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// This snippet assumes the presence of the Dart Test Certificate in the user's 'My' certificate store. 
        /// The Dart Test Certificate may be installed from the component's Start Menu program group.
        /// For a UI-based certificate selection, please see the CertificateListForm included with our 
        /// WinForms samples.
        /// &lt;/remarks&gt;
        /// &lt;param name="targetHost"&gt;The host server specified by the client.&lt;/param&gt;
        /// &lt;param name="localCertificates"&gt;A reference to ClientSecurity.Certificates&lt;/param&gt;
        /// &lt;param name="remoteCertificate"&gt;The certificate used to authenticate the remote party.&lt;/param&gt;
        /// &lt;param name="acceptableIssuers"&gt;A String array of certificate issuers acceptable to the remote party.&lt;/param&gt;
        /// &lt;returns&gt;An X509Certificate to use for establishing the SSL connection.&lt;/returns&gt;
        private X509Certificate selectLocalCertificate(Object sender, string targetHost, 
            X509CertificateCollection localCertificates, X509Certificate remoteCertificate, string[] acceptableIssuers)
        {
            //Try to find the Dart Test Certificate
            X509Store certificateStore = new X509Store(StoreName.My);
            certificateStore.Open(OpenFlags.ReadOnly);
            foreach (X509Certificate2 cert in certificateStore.Certificates)
                if (cert.GetNameInfo(X509NameType.SimpleName, true) == "DartdomCA")
                {
                    certificateStore.Close();
                    return cert;
                }
            //Certificate not found, return null
            return null;
        }

        /// &lt;summary&gt;
        /// Presents the server's certificate for validation.
        /// &lt;/summary&gt;
        /// &lt;param name="certificate"&gt;The certificate presented by the server&lt;/param&gt;
        /// &lt;param name="chain"&gt;The chain of certificate authorities associated with the remote certificate&lt;/param&gt;
        /// &lt;param name="sslPolicyErrors"&gt;One or more errors associated with the server's certificate&lt;/param&gt;
        /// &lt;returns&gt;A Boolean value that specifies whether the presented certificate is accepted for authentication&lt;/returns&gt;
        private bool certificateReceived(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
        {
            //Accept certificate if it passed standard validation.
            if (sslPolicyErrors == SslPolicyErrors.None)
                return true;

            string msg = "The server could not be validated for the following reason(s):";

            if ((sslPolicyErrors &amp; SslPolicyErrors.RemoteCertificateNotAvailable) == SslPolicyErrors.RemoteCertificateNotAvailable)
                msg += Environment.NewLine + "    -The server did not present a certificate.";
            else
            {
                if ((sslPolicyErrors &amp; SslPolicyErrors.RemoteCertificateNameMismatch) == SslPolicyErrors.RemoteCertificateNameMismatch)
                    msg += Environment.NewLine + "    -Certificate name mismatch.";
                if ((sslPolicyErrors &amp; SslPolicyErrors.RemoteCertificateChainErrors) == SslPolicyErrors.RemoteCertificateChainErrors)
                {
                    msg += Environment.NewLine + "    -Certificate chain errors:" + Environment.NewLine;

                    foreach (X509ChainStatus item in chain.ChainStatus)
                        msg += "    --" + item.StatusInformation;
                }
            }

            //Prompt to override security check
            msg += Environment.NewLine + "Override security check?";
            if (MessageBox.Show(msg, "Security Alert: Server could not be validated", MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation) == DialogResult.Yes)
                return true;
            else
                return false;
        }
        </code><code lang="VB">
        Imports System.Net.Security
        Imports System.Security.Authentication
        Imports System.Security.Cryptography.X509Certificates

        ''' &lt;summary&gt;
        ''' Establishes SSL with the provided Tcp object. Typically called immediately after connecting to the server (implicit) 
        ''' or after a command such as STARTTLS is sent to the server (explicit).
        ''' &lt;/summary&gt;
        ''' &lt;param name="myComponent"&gt;Object to establish SSL with&lt;/param&gt;
        ''' &lt;param name="session"&gt;The TcpSession object used for connecting to the server&lt;/param&gt;
        ''' &lt;param name="serverHostName"&gt;The name of the server&lt;/param&gt;
        ''' &lt;param name="protocols"&gt;Protocols the client will accept&lt;/param&gt;
        ''' &lt;param name="checkRevocation"&gt;Check certificate revocation list during authentication&lt;/param&gt;
        Private Sub authenticateTcp(ByVal myComponent As Tcp, ByVal session As TcpSession, ByVal serverHostName As String, ByVal protocols As SslProtocols, ByVal checkRevocation As Boolean)
            'Specify configuration and certificate callback function, and authenticate server
            'Specifying TargetHost is only necessary if TcpSession.RemoteEndPoint.HostNameOrAddress doesn't match the server's certificate
            session.Security.TargetHost = serverHostName
            session.Security.Protocols = protocols
            session.Security.CheckCertificateRevocation = checkRevocation
            session.Security.ValidationCallback = AddressOf certificateReceived
            session.Security.SelectionCallback = AddressOf selectLocalCertificate
            myComponent.AuthenticateAsClient(session)
        End Sub

        ''' &lt;summary&gt;
        ''' Prompts the user to select a certificate for SSL authentication.
        ''' &lt;/summary&gt;
        ''' &lt;remarks&gt;
        ''' This snippet assumes the presence of the Dart Test Certificate in the user's 'My' certificate store. 
        ''' The Dart Test Certificate may be installed from the component's Start Menu program group.
        ''' For a UI-based certificate selection, please see the CertificateListForm included with our 
        ''' WinForms samples.
        ''' &lt;/remarks&gt;
        ''' &lt;param name="targetHost"&gt;The host server specified by the client.&lt;/param&gt;
        ''' &lt;param name="localCertificates"&gt;A reference to ClientSecurity.Certificates&lt;/param&gt;
        ''' &lt;param name="remoteCertificate"&gt;The certificate used to authenticate the remote party.&lt;/param&gt;
        ''' &lt;param name="acceptableIssuers"&gt;A String array of certificate issuers acceptable to the remote party.&lt;/param&gt;
        ''' &lt;returns&gt;An X509Certificate to use for establishing the SSL connection.&lt;/returns&gt;
        Private Function selectLocalCertificate(ByVal sender As Object, ByVal targetHost As String, ByVal localCertificates As X509CertificateCollection, ByVal remoteCertificate As X509Certificate, ByVal acceptableIssuers() As String) As X509Certificate
            'Try to find the Dart Test Certificate
            Dim certificateStore As New X509Store(StoreName.My)
            certificateStore.Open(OpenFlags.ReadOnly)
            For Each cert As X509Certificate2 In certificateStore.Certificates
                If cert.GetNameInfo(X509NameType.SimpleName, True) = "DartdomCA" Then
                    certificateStore.Close()
                    Return cert
                End If
            Next cert
            'Certificate not found, return null
            Return Nothing
        End Function

        ''' &lt;summary&gt;
        ''' Presents the server's certificate for validation.
        ''' &lt;/summary&gt;
        ''' &lt;param name="certificate"&gt;The certificate presented by the server&lt;/param&gt;
        ''' &lt;param name="chain"&gt;The chain of certificate authorities associated with the remote certificate&lt;/param&gt;
        ''' &lt;param name="sslPolicyErrors"&gt;One or more errors associated with the server's certificate&lt;/param&gt;
        ''' &lt;returns&gt;A Boolean value that specifies whether the presented certificate is accepted for authentication&lt;/returns&gt;
        Private Function certificateReceived(ByVal sender As Object, ByVal certificate As X509Certificate, ByVal chain As X509Chain, ByVal sslPolicyErrors As SslPolicyErrors) As Boolean
            'Accept certificate if it passed standard validation.
            If sslPolicyErrors = System.Net.Security.SslPolicyErrors.None Then
                Return True
            End If

            Dim msg As String = "The server could not be validated for the following reason(s):"

            If (sslPolicyErrors And System.Net.Security.SslPolicyErrors.RemoteCertificateNotAvailable) = System.Net.Security.SslPolicyErrors.RemoteCertificateNotAvailable Then
                msg &amp;= Environment.NewLine &amp; "    -The server did not present a certificate."
            Else
                If (sslPolicyErrors And System.Net.Security.SslPolicyErrors.RemoteCertificateNameMismatch) = System.Net.Security.SslPolicyErrors.RemoteCertificateNameMismatch Then
                    msg &amp;= Environment.NewLine &amp; "    -Certificate name mismatch."
                End If
                If (sslPolicyErrors And System.Net.Security.SslPolicyErrors.RemoteCertificateChainErrors) = System.Net.Security.SslPolicyErrors.RemoteCertificateChainErrors Then
                    msg &amp;= Environment.NewLine &amp; "    -Certificate chain errors:" &amp; Environment.NewLine

                    For Each item As X509ChainStatus In chain.ChainStatus
                        msg &amp;= "    --" &amp; item.StatusInformation
                    Next item
                End If
            End If

            'Prompt to override security check
            msg &amp;= Environment.NewLine &amp; "Override security check?"
            If MessageBox.Show(msg, "Security Alert: Server could not be validated", MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation) = System.Windows.Forms.DialogResult.Yes Then
                Return True
            Else
                Return False
            End If
        End Function
        </code></example>
        </member>
        <member name="M:Dart.Sockets.TcpBase.AuthenticateAsServerTaskAsync(Dart.Sockets.ServerSecurity)">
            <summary>
            Authenticates a client when establishing a secure connection.
            </summary>
            <param name="security">Security parameters used during authentication.</param>
            <returns>
            An awaitable task that represents the authentication operation.
            </returns>
            <remarks>
            To accept or reject a certificate "on-the-fly" implement a <see cref="F:Dart.Sockets.Security.ValidationCallback">Security.ValidationCallback</see> function.
            </remarks>
        </member>
        <member name="M:Dart.Sockets.TcpBase.ReadTaskAsync(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Start an awaitable asynchronous read on the socket.
            </summary>
            <param name="buffer">The byte array used to store the received data.</param>
            <param name="offset">The position in the buffer to store the data.</param>
            <param name="count">The maximum number of bytes to receive.</param>
            <returns>
            A task that represents the asynchronous read operation. The value of the TResult parameter contains the <see cref="E:Dart.Sockets.TcpBase.Data">Data</see> 
            object encapsulating the received data (null if the socket is closed).
            </returns>
            <remarks>
            ReadTaskAsync encapsulates <see cref="M:Dart.Sockets.TcpBase.ReadAsync(System.Byte[],System.Int32,System.Int32,Dart.Sockets.TcpAsyncCallback,System.Object)" /> and its callback into an easy-to-use awaitable method, leveraging the benefits of 
            IO completion ports without the complexity of callbacks.
            </remarks>
        </member>
        <member name="M:Dart.Sockets.TcpBase.WriteTaskAsync(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Start an awaitable asynchronous write on the socket.
            </summary>
            <param name="buffer">Byte array of data to send.</param>
            <param name="offset">The position in the data buffer at which to begin sending data.</param>
            <param name="count">The number of bytes to send.</param>
            <returns>
            A task that represents the asynchronous read operation. The value of the TResult parameter contains the <see cref="E:Dart.Sockets.TcpBase.Data">Data</see> 
            object encapsulating the written data (null if the socket is closed).
            </returns>
            <remarks>
            WriteTaskAsync encapsulates <see cref="M:Dart.Sockets.TcpBase.WriteAsync(System.Byte[],System.Int32,System.Int32,Dart.Sockets.TcpAsyncCallback,System.Object)" /> and its callback into an easy-to-use awaitable method, leveraging the benefits of 
            IO completion ports without the complexity of callbacks.
            </remarks>
        </member>
        <member name="M:Dart.Sockets.TcpBase.Dispose(System.Boolean)">
            <summary>
            Disposes of TcpBase and its associated resources.
            </summary>
        </member>
        <member name="E:Dart.Sockets.TcpBase.Data">
            <summary>
            Raised when <see cref="M:Dart.Sockets.TcpBase.Marshal(Dart.Sockets.Data,System.String,System.Object)" /> is used. 
            </summary>
            <remarks>
                See the <see cref="P:Dart.Sockets.ComponentBase.SynchronizingObject">SynchronizingObject</see> property for information on 
                updating UI controls in your event handler.
            </remarks>
        </member>
        <member name="E:Dart.Sockets.TcpBase.StateChanged">
            <summary>
            Raised when the value of the State property changes.
            </summary>
            <remarks>
                <para>
            See the <see cref="P:Dart.Sockets.ComponentBase.SynchronizingObject">SynchronizingObject</see> property for information on 
            updating UI controls in your event handler.
            </para>
                <para>
            This event can be raised during a Read call if the remote host closes the connection. In this scenario, a form 
            should not be disposed of within this event handler if the Dart component was created on the form (this includes 
            calling Form.Close if Form.Show was used to show it). Instead, the component can be created elsewhere and passed to 
            the form, or the form can be disposed of after the posted Read returns.
            </para>
            </remarks>
            <example>
        This example demonstrates using the StateChanged event and State property to update the UI.
        <code lang="C#">
        private void myComponent_StateChanged(object sender, EventArgs e)
        {
            if (myComponent.State == ConnectionState.Closed)
                this.Text = "Not Connected";
            else if (myComponent.State == ConnectionState.Connected)
                this.Text = "Connected to " + myComponent.RemoteEndPoint.ToString();
            else
                this.Text = "Securely connected to " + myComponent.RemoteEndPoint.ToString();
        }
        </code><code lang="VB">
        Private Sub myComponent_StateChanged(ByVal sender As Object, ByVal e As EventArgs)
            If myComponent.State = ConnectionState.Closed Then
                Me.Text = "Not Connected"
            ElseIf myComponent.State = ConnectionState.Connected Then
                Me.Text = "Connected to " &amp; myComponent.RemoteEndPoint.ToString()
            Else
                Me.Text = "Securely connected to " &amp; myComponent.RemoteEndPoint.ToString()
            End If
        End Sub
        </code></example>
        </member>
        <member name="E:Dart.Sockets.TcpBase.Log">
            <summary>
            Raised when data is read or written.
            </summary>
            <remarks>
                The handler must be added before connecting.
                See the <see cref="P:Dart.Sockets.ComponentBase.SynchronizingObject">SynchronizingObject</see> property for information on 
                updating UI controls in your event handler.
            </remarks>
            <example>
        This example demonstrates logging sent and received data to a textbox.
        <code lang="C#">
        private void myComponent_Log(object sender, DataEventArgs e)
        {
            string prompt = (e.Data.Direction == DataDirection.In) ? "Recv: " : "Sent: ";
            textBox1.AppendText(prompt + e.Data.ToString() + Environment.NewLine);
        }
        </code><code lang="VB">
        Private Sub myComponent_Log(ByVal sender As Object, ByVal e As DataEventArgs)
            Dim prompt As String = If(e.Data.Direction = DataDirection.In, "Recv: ", "Sent: ")
            textBox1.AppendText(prompt &amp; e.Data.ToString() &amp; Environment.NewLine)
        End Sub
        </code></example>
        </member>
        <member name="P:Dart.Sockets.TcpBase.State">
            <summary>
            Gets the status of the connection as of the last socket operation.
            </summary>
            <example>
        This example demonstrates using the StateChanged event and State property to update the UI.
        <code lang="C#">
        private void myComponent_StateChanged(object sender, EventArgs e)
        {
            if (myComponent.State == ConnectionState.Closed)
                this.Text = "Not Connected";
            else if (myComponent.State == ConnectionState.Connected)
                this.Text = "Connected to " + myComponent.RemoteEndPoint.ToString();
            else
                this.Text = "Securely connected to " + myComponent.RemoteEndPoint.ToString();
        }
        </code><code lang="VB">
        Private Sub myComponent_StateChanged(ByVal sender As Object, ByVal e As EventArgs)
            If myComponent.State = ConnectionState.Closed Then
                Me.Text = "Not Connected"
            ElseIf myComponent.State = ConnectionState.Connected Then
                Me.Text = "Connected to " &amp; myComponent.RemoteEndPoint.ToString()
            Else
                Me.Text = "Securely connected to " &amp; myComponent.RemoteEndPoint.ToString()
            End If
        End Sub
        </code></example>
        </member>
        <member name="P:Dart.Sockets.TcpBase.ConnectTime">
            <summary>
            Returns the DateTime the connection was established.
            </summary>
        </member>
        <member name="P:Dart.Sockets.TcpBase.CloseTime">
            <summary>
            Returns the DateTime the connection was closed.
            </summary>
        </member>
        <member name="P:Dart.Sockets.TcpBase.NetworkStream">
            <summary>
            Returns the <see cref="T:System.Net.Sockets.NetworkStream">NetworkStream</see> object created when Connect() is called.
            </summary>
            <remarks>Returns null when no TCP connection exists.</remarks>
        </member>
        <member name="P:Dart.Sockets.TcpBase.RemoteEndPoint">
            <summary>
            Gets the remote address and port of the connection.
            </summary>
            <value>The <see cref="T:System.Net.IPEndPoint">Socket.RemoteEndPoint</see>. This value persists after the connection is closed.</value>
            <example>
        This example demonstrates using the StateChanged event and State property to update the UI.
        <code lang="C#">
        private void myComponent_StateChanged(object sender, EventArgs e)
        {
            if (myComponent.State == ConnectionState.Closed)
                this.Text = "Not Connected";
            else if (myComponent.State == ConnectionState.Connected)
                this.Text = "Connected to " + myComponent.RemoteEndPoint.ToString();
            else
                this.Text = "Securely connected to " + myComponent.RemoteEndPoint.ToString();
        }
        </code><code lang="VB">
        Private Sub myComponent_StateChanged(ByVal sender As Object, ByVal e As EventArgs)
            If myComponent.State = ConnectionState.Closed Then
                Me.Text = "Not Connected"
            ElseIf myComponent.State = ConnectionState.Connected Then
                Me.Text = "Connected to " &amp; myComponent.RemoteEndPoint.ToString()
            Else
                Me.Text = "Securely connected to " &amp; myComponent.RemoteEndPoint.ToString()
            End If
        End Sub
        </code></example>
        </member>
        <member name="P:Dart.Sockets.TcpBase.SocketOption">
            <summary>
            Gets and sets the socket options for classes derived from TcpBase.
            </summary>
        </member>
        <member name="P:Dart.Sockets.TcpBase.SslStream">
            <summary>
            Returns the <see cref="T:System.Net.Security.SslStream">SslStream</see> object created when AuthenticateAsClient or AuthenticateAsServer are called.
            </summary>
            <remarks>Returns null when no secure connection exists.</remarks>
        </member>
        <member name="P:Dart.Sockets.PtyBase.Pty">
            <summary>
            Gets or sets a display control to use for automatic pseudo terminal support.
            </summary>
            <remarks>
                <para>
                Set this property to a control derived from <see cref="T:System.Windows.Forms.TextBoxBase">TextBoxBase</see> and call
                <see cref="M:Dart.Sockets.TcpBase.Connect(Dart.Sockets.TcpSession)">Connect</see> to start an online session.
                Data received from the host will be displayed, and keyboard input will automatically be sent to
                the remote host.
                </para>
                <para>
                The Multiline property on the Pty control is set to true. You may wish to set the Font property to a fixed-width font and set the 
            Wordwrap property to false.
                Also, if the SynchronizingObject is null, it will be set to the Pty control.
                </para>
                <para>
                These properties can be changed from their default values after this property is set.
                </para>
            </remarks>
        </member>
        <member name="P:Dart.Sockets.PtyBase.CRLF">
            <summary>
            Set to true if the Pty property is used and a CR should be converted to a CRLF for sending.
            </summary>
            <remarks>This property controls the behavior of the TextBox assigned to the Pty property.
            For example, the Echo protocol echoes back any sent character. Since as textbox requires a CRLF, set this property to 
            true so that a CRLF will be generated when the return key is pressed. Defaults to false.</remarks>
        </member>
        <member name="P:Dart.Sockets.PtyBase.LocalEcho">
            <summary>
            Set to true if the Pty property is used and keystrokes should be displayed in the textbox.
            </summary>
            <remarks>This property controls the behavior of the TextBox assigned to the Pty property.
            For example, the Pop protocol does not echo sent characters to the screen. Set this property to 
            true to see the characters being sent to the Pop server. Defaults to false.</remarks>
        </member>
        <member name="T:Dart.Sockets.IPEndPoint">
            <summary>
            Allows user to specify a range of IPEndPoints for local binding. Also resolves hostnames and saves them for future use.
            </summary>
        </member>
        <member name="M:Dart.Sockets.IPEndPoint.#ctor">
            <summary>
            Creates an IPEndPoint using IPAddress.Any and an ephemeral port (0).
            </summary>
        </member>
        <member name="M:Dart.Sockets.IPEndPoint.#ctor(System.Net.Sockets.AddressFamily)">
            <summary>
            Creates an IPEndPoint using IPAddress.Any or IPAddress.IPv6Any and an ephemeral port (0).
            </summary>
            <param name="addressFamily">AddressFamily to match.</param>
        </member>
        <member name="M:Dart.Sockets.IPEndPoint.#ctor(System.Net.IPAddress,System.Int32)">
            <summary>
            Creates an IPEndPoint using a specified IPAddress and port.
            </summary>
            <param name="address">An IPv4 or IPv6 address.</param>
            <param name="port">The port to bind to.</param>
        </member>
        <member name="M:Dart.Sockets.IPEndPoint.#ctor(System.Net.IPAddress,System.Int32,System.Int32)">
            <summary>
            Creates an IPEndPoint using an IPAddress, port, and port range.
            </summary>
            <param name="address">An IPv4 or IPv6 address.</param>
            <param name="port">The port to bind to.</param>
            <param name="range">The range of ports, starting at port, to attempt to bind to.</param>
            <para>
            The socket will try to bind to the specified <i>port</i>. Upon failure, it will try to bind to each 
            successive port up to (<i>port</i> + <i>range</i>), until successful. 
            An Exception is raised if all binding attempts fail.
            </para>
        </member>
        <member name="M:Dart.Sockets.IPEndPoint.#ctor(System.String)">
            <summary>
            Creates an IPEndPoint using a hostname or address, and port 0.
            </summary>
            <param name="hostNameOrAddress">A hostname or an IPv4 or IPv6 address. Empty string resolves to the first local IPv4 network interface.</param>
            <remarks>
                <para>
            The <i>hostNameOrAddress</i> parameter is limited to 126 characters in pre-4.0 versions of the .NET Framework, and 255 characters in versions 4.0 and higher.
            </para>
                <para>
            If <i>hostNameOrAddress</i> is a hostname, resolves to the IPv4 address.
            </para>
            </remarks>
        </member>
        <member name="M:Dart.Sockets.IPEndPoint.#ctor(System.String,System.Int32)">
            <summary>
            Creates an IPEndPoint using a hostname or address, and port.
            </summary>
            <param name="hostNameOrAddress">A hostname or an IPv4 or IPv6 address. Empty string resolves to the first local IPv4 network interface.</param>
            <param name="port">The port to bind to.</param>
            <remarks>
                <para>
            The <i>hostNameOrAddress</i> parameter is limited to 126 characters in pre-4.0 versions of the .NET Framework, and 255 characters in versions 4.0 and higher.
            </para>
                <para>
            If <i>hostNameOrAddress</i> is a hostname, resolves to the IPv4 address.
            </para>
            </remarks>
        </member>
        <member name="M:Dart.Sockets.IPEndPoint.#ctor(System.String,System.Net.Sockets.AddressFamily,System.Int32)">
            <summary>
            Creates an IPEndPoint using a hostname or address, port, and AddressFamily.
            </summary>
            <param name="hostNameOrAddress">A hostname or string address. Empty string resolves to the first local network interface in the specified AddressFamily.</param>
            <param name="addressFamily">The <see cref="T:System.Net.Sockets.AddressFamily" /> to match if resolving a hostname.</param>
            <param name="port">The port to bind to.</param>
            <remarks>
                <para>
            The <i>hostNameOrAddress</i> parameter is limited to 126 characters in pre-4.0 versions of the .NET Framework, and 255 characters in versions 4.0 and higher.
            </para>
            </remarks>
        </member>
        <member name="M:Dart.Sockets.IPEndPoint.#ctor(System.String,System.Net.Sockets.AddressFamily,System.Int32,System.Int32)">
            <summary>
            Creates an IPEndPoint using a hostname or address, address family, port and range.
            </summary>
            <param name="hostNameOrAddress">A hostname or string address. Empty string resolves to the first local network interface in the specified AddressFamily.</param>
            <param name="addressFamily">The <see cref="T:System.Net.Sockets.AddressFamily">AddressFamily</see> to match if resolving a hostname.</param>
            <param name="port">The port to bind to.</param>
            <param name="range">The range of ports, starting at port, to attempt to bind to.</param>
            <remarks>
                <para>
            The socket will try to bind to the specified <i>port</i>. Upon failure, it will try with each 
            successive port up to (<i>port</i> + <i>range</i>), until successful. 
            An Exception is raised if all binding attempts fail.
            </para>
                <para>
            The <i>hostNameOrAddress</i> parameter is limited to 126 characters in pre-4.0 versions of the .NET Framework, and 255 characters in versions 4.0 and higher.
            </para>
            </remarks>
        </member>
        <member name="M:Dart.Sockets.IPEndPoint.#ctor(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Creates an IPEndPoint using a hostname or address, address, port and range.
            </summary>
            <param name="hostNameOrAddress">A hostname or string address.</param>
            <param name="address">The IPAddress in string notation.</param>
            <param name="port">The port to bind to.</param>
            <param name="range">The range of ports, starting at port, to attempt to bind to.</param>
            <remarks>
                <para>
            This constructor is typically used to serialize the IPEndPoint and does not resolve hostNameOrAddress. 
            The hostname can be needed for some proxies.
            </para>
            </remarks>
        </member>
        <member name="F:Dart.Sockets.IPEndPoint.Range">
            <summary>
            The socket will be bound to a port between IPEndPoint.Port and (IPEndPoint.Port + Range), inclusive.
            </summary>
        </member>
        <member name="P:Dart.Sockets.IPEndPoint.HostNameOrAddress">
            <summary>
            Gets or sets the host name or address resolved to create this IPEndPoint. Also performs a DNS resolution.
            </summary>
            <remarks>The value of this property is limited to 126 characters in pre-4.0 versions of the .NET Framework,
            and 255 characters in versions 4.0 and higher. IDN encoding is performed for DNS resolution if a non-ASCII hostname is provided.</remarks>
        </member>
        <member name="P:Dart.Sockets.IPEndPoint.HostNameOrAddressColonPort">
            <summary>
            The host name or address used to create this IPEndPoint with ":port" appended.
            </summary>
            <remarks>If HostNameOrAddress is an IPv6 address, the format includes square brackets as follows: [xx:yy...zz]:port.</remarks>
        </member>
        <member name="P:Dart.Sockets.IPEndPoint.Port">
            <summary>
            Gets or sets the port number of the endpoint.
            </summary>
        </member>
        <member name="P:Dart.Sockets.IPEndPoint.Address">
            <summary>
            Gets or sets the address of the endpoint.
            </summary>
        </member>
        <member name="T:Dart.Sockets.SocketOption">
            <summary>
            Contains socket options that may be set by TCP and UDP sockets. These options are automatically applied to the connection used.
            </summary>
        </member>
        <member name="F:Dart.Sockets.SocketOption.LocalEndPoint">
            <summary>
            Gets or sets the desired local IPEndPointRange (address, port, range) the socket should be bound to.
            </summary>
            <remarks>
            Socket.Bind will be used bind the socket to the specified endpoint(s).
            .mjb.11-17-10.Remove from public interface...set from within Connect() instead.
            </remarks>
        </member>
        <member name="P:Dart.Sockets.SocketOption.ExclusiveAddressUse">
            <summary>
            When set to true, forbids multiple socket bindings to the same address.
            <remarks>Set this value to true to ensure you have exclusive use of the local endpoint. Socket.ExclusiveAddressUse is set to this
            value before Socket.Bind is used.</remarks></summary>
        </member>
        <member name="P:Dart.Sockets.SocketOption.ReceiveBufferSize">
            <summary>
            Gets or sets a value that specifies the size of the system receive buffer.
            </summary>
            <value>An integer with a default value of 32786.</value>
            <remarks>
                <para>
                Increasing the buffer size may help performance when transferring large amounts of data,
                or when high bandwidth, high latency connections (such as a satellite broadband provider) are used.
                </para>
                <para>
                The value cannot be changed on CF devices.
                </para>
            </remarks>
        </member>
        <member name="P:Dart.Sockets.SocketOption.ReceiveTimeout">
            <summary>
            Gets or sets a value that specifies the amount of time after which the underlying Socket.Receive call will time out.
            </summary>
            <value>The time-out value in milliseconds.</value>
            <remarks>
            A value of 0 or -1 indicates an infinite time-out period.
            </remarks>
        </member>
        <member name="P:Dart.Sockets.SocketOption.ReuseAddress">
            <summary>
            When set to true, allows multiple socket bindings to the same address.
            <remarks>Set this value to true to allow multiple sockets to bind to the same local address.</remarks></summary>
        </member>
        <member name="P:Dart.Sockets.SocketOption.SendBufferSize">
            <summary>
            Gets or sets a value that specifies the size of the system send buffer.
            </summary>
            <value>An integer with a default value of 8192.</value>
            <remarks>
                <para>
                Increasing the buffer size may help performance when transferring large amounts of data,
                or when high bandwidth, high latency connections (such as a satellite broadband provider) are used.
                </para>
            </remarks>
        </member>
        <member name="P:Dart.Sockets.SocketOption.SendTimeout">
            <summary>
            Gets or sets a value that specifies the amount of time after which the underlying Socket Send call will time out.
            </summary>
            <value>The time-out value in milliseconds. The default value is 0, which indicates an infinite time-out period.</value>
            <remarks>
                <para>
                Values between 1 and 499 will be changed to 500, as 500 is the minimum positive value. 
                Values of 0 and -1 indicate an infinite time-out period.
                </para>
                <para>
                This option has no affect on CF devices (the Write method will not time out).
                </para>
            </remarks>
        </member>
        <member name="T:Dart.Sockets.TcpSocketOption">
            <summary>
            Contains socket options that may be set by TCP sockets.
            </summary>
        </member>
        <member name="P:Dart.Sockets.TcpSocketOption.KeepAliveTime">
            <summary>
            The connection idle time in milliseconds before TCP will begin sending keepalives.
            </summary>
            <remarks>
                <para>Set to 0 to disable keepalives. Defaults to 7,200,000 (2 hours).</para>
                <para>This property is not implemented in MONO.</para>
            </remarks>
        </member>
        <member name="P:Dart.Sockets.TcpSocketOption.KeepAliveInterval">
            <summary>
            The time in milliseconds between retransmission of keepalives once the KeepAliveTime has expired.
            </summary>
            <remarks>
                <para>
            Once KeepAliveTime has expired, keepalives are sent every KeepAliveInterval milliseconds until a response
            is received, up to the maximum established by TcpMaxDataRetransmissions (OS-level configuration) before the connection is terminated.
            The default is 1000 (1 sec).
            </para>
                <para>This property is not implemented in MONO.</para>
            </remarks>
        </member>
        <member name="P:Dart.Sockets.TcpSocketOption.NoDelay">
            <summary>
            Gets or sets a value that disables the use of Nagle's algorithm so that data is sent immediately.
            </summary>
            <value>False if Nagle's algorithm is used; otherwise true. The default value is false.</value>
            <remarks>
                <para>
                When small pieces of data (such as single bytes) are send many times consecutively, inefficient packets 
                can be sent with one byte of useful data and 40 bytes of header information. 
                Nagle's algorithm specifies that this type of data should be automatically concatenated and sent in a single packet. 
                When true, Nagle's algorithm is defeated and data is immediately sent in a dedicated packet. 
                When false, Nagle's algorithm is used and consecutive Socket Send calls might send data in a single (more efficient) packet.
                </para>
                <para>
                Setting this property to true may result in a speed optimization (because packets are sent immediately, 
                without having to wait to see if Send is called again). 
                Setting this property to false results in data being transmitted more efficiently.
                </para>
            </remarks>
        </member>
        <member name="P:Dart.Sockets.TcpSocketOption.OutOfBandInline">
            <summary>
            Gets or sets a value that indicates whether out-of-band (urgent) data is read as normal in-line data. 
            </summary>
            <value>True if urgent data is to be read as normal in-line data, otherwise false. The default value is false.</value>
            <remarks>
                <para>
                When the "urgent" socket flag is set, the packet contains data that should be acted upon before "non-urgent" data. 
                Setting this property to true will cause this urgent data to be read in-line. 
                To minimize interoperability problems, developers are advised not to use out-of-band data unless it is required
                to interoperate with an existing service.
                </para>
            </remarks>
        </member>
        <member name="P:Dart.Sockets.TcpSocketOption.ReceiveTimeout">
            <summary>
            Gets or sets a value that specifies the amount of time after which the underlying TCP Socket.Receive call will time out.
            </summary>
            <value>The time-out value in milliseconds.</value>
            <remarks>
            Values between 1 and 499 will be changed to 500, as 500 is the minimum positive value. A value of 0 or -1 indicates an infinite time-out period.
            </remarks>
        </member>
        <member name="T:Dart.Sockets.TcpSession">
            <summary>
            Holds the configuration used by TCP.
            </summary>
        </member>
        <member name="T:Dart.Sockets.Session">
            <summary>
            Holds the configuration common to UDP and TCP.
            </summary>
        </member>
        <member name="M:Dart.Sockets.Session.#ctor">
            <summary>
            Default constructor for Session.
            </summary>
        </member>
        <member name="M:Dart.Sockets.Session.#ctor(Dart.Sockets.IPEndPoint)">
            <summary>
            Constructor for Session with a Remote IPEndPoint parameter.
            </summary>
            <param name="remoteEP">The remote IPEndPoint to connect to.</param>
        </member>
        <member name="P:Dart.Sockets.Session.RemoteEndPoint">
            <summary>
            EndPoint of the remote host to connect to.
            </summary>
        </member>
        <member name="P:Dart.Sockets.Session.LocalEndPoint">
            <summary>
            EndPoint to bind to locally.
            </summary>
            <remarks>
                <para>
            Use this property to control the use of IPv4/IPv6, the IP interface to bind to (for multi-homed hosts), and the port or port-range to use. 
            Defaults to AddressFamily.InterNetworkV4, IPAddress.Any, and a port selected by the system (ephemeral port 0).
            </para>
                <para>
            To use AddressFamily.InterNetworkV6, create a new IPEndPoint that specifies this AddressFamily. A Socket will be created that can connect to
            both IPv4 and IPv6 hosts. This is called a "dual stack", allowing clients to connect to both IPv4 and IPv6 servers, and allowing servers
            to accept connections from both IPv4 and IPv6 clients.
            </para>
                <para>
            If IPEndPoint.Any is not desired, specify the hostname or address in the constructor.
            </para>
                <para>
            If a random ephemeral port is not desired, specify the port or range in the constructor.
            </para>
            </remarks>
        </member>
        <member name="M:Dart.Sockets.TcpSession.#ctor">
            <summary>
            Default constructor for TcpSession.
            </summary>
        </member>
        <member name="M:Dart.Sockets.TcpSession.#ctor(Dart.Sockets.IPEndPoint)">
            <summary>
            Constructor for TcpSession with a Remote IPEndPoint parameter.
            </summary>
            <param name="remoteEP">The remote IPEndPoint to connect to.</param>
        </member>
        <member name="P:Dart.Sockets.TcpSession.Security">
            <summary>
            Specifies the client-side SSL options. See the <see cref="T:Dart.Sockets.ClientSecurity" /> class for more information.
            </summary>
            <value>
                <see cref="T:Dart.Sockets.ClientSecurity" />
            </value>
        </member>
        <member name="P:Dart.Sockets.TcpSession.Proxy">
            <summary>
            Defines the optional server proxy configuration.
            </summary>
            <remarks>
            Use this property to define the server proxy configuration.
            </remarks>
        </member>
        <member name="P:Dart.Sockets.TcpSession.ConnectTimeout">
            <summary>
            Gets or sets a value that specifies the amount of time (in milliseconds) after which a call to <see cref="M:Dart.Sockets.TcpBase.Connect(Dart.Sockets.TcpSession)" /> will time out.
            </summary>
            <value>The timeout value in milliseconds. The default value is -1, which defers to the system timeout.</value>
            <remarks>
            This property is used to cancel a connect request early; it does not override the system-level connect timeout.
            </remarks>
        </member>
        <member name="T:Dart.Sockets.DataException">
            <summary>
            Thrown when the expected data could not be read.
            </summary>
        </member>
        <member name="F:Dart.Sockets.DataException.DataRead">
            <summary>
            Data read from the socket before a failure generated this exception.
            </summary>
        </member>
        <member name="T:Dart.Sockets.TcpAsyncCallback">
            <summary>
            References the method to invoke on an IO completion thread when the corresponding asynchronous operation completes.
            </summary>
            <param name="tcp">The TcpBase object that initiated the asynchronous operation.</param>
            <param name="data">The Data object containing received/sent data. Null for connect operations or if the socket is closed.</param>
            <param name="exception">Populated if the operation threw an exception, otherwise null.</param>
            <param name="state">State object passed into the asynchronous call.</param>
        </member>
        <member name="T:Dart.Sockets.UdpBase">
            <summary>
            Base class for upper-layer protocols based on UDP.
            </summary>
        </member>
        <member name="M:Dart.Sockets.UdpBase.#ctor">
            <summary>
            Default constructor for UdpBase
            </summary>
        </member>
        <member name="M:Dart.Sockets.UdpBase.Open(System.Int32)">
            <summary>
            Opens a socket on all IPv4 network interfaces and the specified port.
            </summary>
            <param name="port">The port to send and receive datagrams from.</param>
        </member>
        <member name="M:Dart.Sockets.UdpBase.Open(System.Net.IPEndPoint)">
            <summary>
            Opens a socket on the specified local IPEndPoint.
            </summary>
            <param name="localEP">The <see cref="T:System.Net.IPEndPoint" /> to send and receive datagrams from. Can specify a port range
            by using <see cref="T:Dart.Sockets.IPEndPoint" />.</param>
        </member>
        <member name="M:Dart.Sockets.UdpBase.Close">
            <summary>
            Close the socket and release all resources.
            </summary>
        </member>
        <member name="M:Dart.Sockets.UdpBase.JoinMulticastGroup(System.Net.IPAddress)">
            <summary>
            Join the specified multicast group for receiving datagrams.
            </summary>
            <remarks>
                <para>
            Use the JoinMulticastGroup method to join a multicast group. Useful when
            you wish for datagrams to be sent to multiple hosts. The host
            is able to receive all datagrams sent to the specified multicast address
            and port.
            </para>
                <para>
            Multicast groups are specified as an IP Address within a specified 
            range of addresses. This group of addresses, also know as class D IP 
            Addresses, are in the range from 224.0.0.0 through 239.255.255.255. In 
            order to receive packets sent to a multicast group (using Receive), you must first join 
            the group using this method.
            </para>
                <para>
            Using multicasting over broadcasting reduces the load on hosts that are not
            interested in the data sent.
            </para>
            </remarks>
            <param name="groupAddress">The System.Net.IPAddress specifying the multicast group address to join.</param>
            <exception cref="T:System.Net.Sockets.SocketException">The multicast address is unknown, invalid, or unable to be resolved.</exception>
            <example>
        The following example demonstrates joining a multicast group, sending data to it, receiving that data, and leaving the multicast group.
        <code lang="C#">
        private void button1_Click(object sender, EventArgs e)
        {
            udp1.Start(multicastWorker, null);
        }

        private void multicastWorker(object state)
        {
            IPEndPoint groupEndPoint = new IPEndPoint("239.0.0.1", 32000);
            udp1.Open(32000);
            udp1.JoinMulticastGroup(groupEndPoint.Address);
            udp1.Send("hello world!", groupEndPoint);
            byte[] buffer = new byte[1024];
            Datagram datagram = udp1.Receive(buffer);
            //Marshal data to UI for display
            udp1.Marshal(datagram.ToString(), null);
            udp1.LeaveMulticastGroup(groupEndPoint.Address);
            udp1.Close();
        }

        void udp1_UserState(object sender, UserStateEventArgs e)
        {
            textBox1.AppendText(e.Message);
        }
        </code><code lang="VB">
        Private Sub button1_Click(ByVal sender As Object, ByVal e As EventArgs) Handles button1.Click
            udp1.Start(AddressOf multicastWorker, Nothing)
        End Sub

        Private Sub multicastWorker(ByVal state As Object)
            Dim groupEndPoint As New IPEndPoint("239.0.0.1", 32000)
            udp1.Open(32000)
            udp1.JoinMulticastGroup(groupEndPoint.Address)
            udp1.Send("hello world!", groupEndPoint)
            Dim buffer(1023) As Byte
            Dim datagram As Datagram = udp1.Receive(buffer)
            'Marshal data to UI for display
            udp1.Marshal(datagram.ToString(), Nothing)
            udp1.LeaveMulticastGroup(groupEndPoint.Address)
            udp1.Close()
        End Sub

        Private Sub udp1_UserState(ByVal sender As Object, ByVal e As UserStateEventArgs)
            textBox1.AppendText(e.Message)
        End Sub
        </code></example>
        </member>
        <member name="M:Dart.Sockets.UdpBase.LeaveMulticastGroup(System.Net.IPAddress)">
            <summary>
            Leave the specified multicast group for receiving datagrams.
            </summary>
            <remarks>
                <para>
            Use LeaveMulticastGroup to leave a multicast group. <i>groupAddress</i> specifies the
            multicast address group to leave. The host will no longer be 
            able to receive datagrams sent to the multicasted address group. The host will still be listening
            and will still be able to receive datagrams sent to the host's
            local address/port.
            </para>
            </remarks>
            <param name="groupAddress">The System.Net.IPAddress specifying the multicast group address to leave.</param>
            <exception cref="T:System.Net.Sockets.SocketException">The multicast address is unknown, invalid, or unable to be resolved.</exception>
            <example>
        The following example demonstrates joining a multicast group, sending data to it, receiving that data, and leaving the multicast group.
        <code lang="C#">
        private void button1_Click(object sender, EventArgs e)
        {
            udp1.Start(multicastWorker, null);
        }

        private void multicastWorker(object state)
        {
            IPEndPoint groupEndPoint = new IPEndPoint("239.0.0.1", 32000);
            udp1.Open(32000);
            udp1.JoinMulticastGroup(groupEndPoint.Address);
            udp1.Send("hello world!", groupEndPoint);
            byte[] buffer = new byte[1024];
            Datagram datagram = udp1.Receive(buffer);
            //Marshal data to UI for display
            udp1.Marshal(datagram.ToString(), null);
            udp1.LeaveMulticastGroup(groupEndPoint.Address);
            udp1.Close();
        }

        void udp1_UserState(object sender, UserStateEventArgs e)
        {
            textBox1.AppendText(e.Message);
        }
        </code><code lang="VB">
        Private Sub button1_Click(ByVal sender As Object, ByVal e As EventArgs) Handles button1.Click
            udp1.Start(AddressOf multicastWorker, Nothing)
        End Sub

        Private Sub multicastWorker(ByVal state As Object)
            Dim groupEndPoint As New IPEndPoint("239.0.0.1", 32000)
            udp1.Open(32000)
            udp1.JoinMulticastGroup(groupEndPoint.Address)
            udp1.Send("hello world!", groupEndPoint)
            Dim buffer(1023) As Byte
            Dim datagram As Datagram = udp1.Receive(buffer)
            'Marshal data to UI for display
            udp1.Marshal(datagram.ToString(), Nothing)
            udp1.LeaveMulticastGroup(groupEndPoint.Address)
            udp1.Close()
        End Sub

        Private Sub udp1_UserState(ByVal sender As Object, ByVal e As UserStateEventArgs)
            textBox1.AppendText(e.Message)
        End Sub
        </code></example>
        </member>
        <member name="M:Dart.Sockets.UdpBase.Receive(System.Byte[])">
            <summary>
            Receive a datagram.
            </summary>
            <param name="buffer">A byte array to be filled with the data received.</param>
            <remarks>
                <para>Use the Receive method to receive a datagram into <i>buffer</i>.
            This method also returns a Datagram object encapsulating
            the datagram received. <see cref="P:Dart.Sockets.Segment.Buffer" /> contains the actual datagram data (equivalent to <i>buffer</i>). 
            <see cref="F:Dart.Sockets.Datagram.Origin" /> contains
            the endpoint of the remote host from which the datagram was sent.
            </para>
                <para>
            A UDP datagram provides little functionality over an IP datagram, adding a port 
            number field (allows demultiplexing on the receiving host) and a checksum field
            (provides basic error handling).
            Unlike TCP, UDP datagrams are sent as a unit. If Send is called
            3 times to send 3 datagrams to a host, the receiving host will have 
            to call Receive 3 times. Also, the size of each datagram sent will equal
            the size of each datagram received by the receiving host. In addition, since 
            UDP is a connectionless protocol, datagrams sent to the host are not 
            guaranteed to be delivered. Therefore, any required error checking (outside of UDP's checksum
            implementation) will have to be done by the application-layer protocol.
            </para>
            </remarks>
            <returns>
            A <see cref="T:Dart.Sockets.Datagram" /> object encapsulating the datagram received. Returns null when the local socket is closed.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <i>buffer</i> is null.</exception>
        </member>
        <member name="M:Dart.Sockets.UdpBase.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
            <summary>
            Receive a datagram.
            </summary>
            <param name="buffer">A byte array to be filled with the data received.</param>
            <param name="offset">Location where received bytes are to placed.</param>
            <param name="size">The number of bytes to receive.</param>
            <param name="socketFlags">User specified SocketFlags.</param>
            <remarks>
                <para>Use the Receive method to receive a datagram into <i>buffer</i>.
            This method also returns a Datagram object encapsulating
            the datagram received. <see cref="P:Dart.Sockets.Segment.Buffer" /> contains the actual datagram data (equivalent to <i>buffer</i>). 
            <see cref="F:Dart.Sockets.Datagram.Origin" /> contains
            the endpoint of the remote host from which the datagram was sent.
            </para>
                <para>
            A UDP datagram provides little functionality over an IP datagram, adding a port 
            number field (allows demultiplexing on the receiving host) and a checksum field
            (provides basic error handling).
            Unlike TCP, UDP datagrams are sent as a unit. If Send is called
            3 times to send 3 datagrams to a host, the receiving host will have 
            to call Receive 3 times. Also, the size of each datagram sent will equal
            the size of each datagram received by the receiving host. In addition, since 
            UDP is a connectionless protocol, datagrams sent to the host are not 
            guaranteed to be delivered. Therefore, any required error checking (outside of UDP's checksum
            implementation) will have to be done by the application-layer protocol.
            </para>
            </remarks>
            <returns>
            A <see cref="T:Dart.Sockets.Datagram" /> object encapsulating the datagram received. Returns null when the local socket is closed.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <i>buffer</i> is null.</exception>
        </member>
        <member name="M:Dart.Sockets.UdpBase.ReceiveAsync(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,Dart.Sockets.UdpAsyncCallback,System.Object)">
            <summary>
            Receive a datagram asynchronously.
            </summary>
            <param name="buffer">A byte array to be filled with the data received.</param>
            <param name="offset">Location where received bytes are to placed.</param>
            <param name="size">The number of bytes to receive.</param>
            <param name="socketFlags">User specified SocketFlags.</param>
            <param name="callback">A <see cref="T:Dart.Sockets.UdpAsyncCallback" /> delegate referencing the method to invoke on an IO completion thread when the operation completes.</param>
            <param name="state">Object to pass into the callback method when the operation completes; can be null.</param>
            <remarks>
                <para>
            Use the ReceiveAsync method to receive a datagram into <i>buffer</i> asynchronously.
            This method returns immediately and invokes the provided UdpAsyncCompleted delegate
            on an IO Completion thread after a datagram has been received.
            </para>
                <para>
            A UDP datagram provides little functionality over an IP datagram, adding a port 
            number field (allows demultiplexing on the receiving host) and a checksum field
            (provides basic error handling).
            Unlike TCP, UDP datagrams are sent as a unit. If Send is called
            3 times to send 3 datagrams to a host, the receiving host will have 
            to call Receive 3 times. Also, the size of each datagram sent will equal
            the size of each datagram received by the receiving host. In addition, since 
            UDP is a connectionless protocol, datagrams sent to the host are not 
            guaranteed to be delivered. Therefore, any required error checking (outside of UDP's checksum
            implementation) will have to be done by the application-layer protocol.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <i>buffer</i> is null.</exception>
        </member>
        <member name="M:Dart.Sockets.UdpBase.Send(System.String,System.String,System.Int32)">
            <summary>
            Send a datagram to the specified remote address and port.
            </summary>
            <remarks>
                <para>Use the Send method to sent a datagram created from the data contained
            in <i>buffer</i> to the specified <i>hostNameOrAddress</i> and <i>port</i>. <i>buffer</i> is
            converted to a byte array before sending.</para>
                <para>
            A UDP datagram provides little functionality over an IP datagram, adding a port 
            number field (allows demultiplexing on the receiving host) and a checksum field
            (provides basic error handling).
            Unlike TCP, UDP datagrams are sent as a unit. If Send is called
            3 times to send 3 datagrams to a host, the receiving host will have 
            to call Receive 3 times. Also, the size of each datagram sent will equal
            the size of each datagram received by the receiving host. In addition, since 
            UDP is a connectionless protocol, any datagrams sent to the host are not 
            guaranteed to be delivered. Therefore, any required error checking (outside of UDP's checksum
            implementation) will have to be done by the application-layer protocol.
            </para>
                <para>To send a broadcast datagram, use "255.255.255.255" as the remote address. To send
            a multicast datagram, use the multicast group address as the remote address after first joining a multicast group by using JoinMulitcastGroup.
            </para>
            </remarks>
            <returns>
            A <see cref="T:Dart.Sockets.Datagram" /> object encapsulating the datagram sent.
            </returns>
            <param name="buffer">A string containing the data to send.</param>
            <param name="hostNameOrAddress">The host address (either dot address or hostname) to send the datagram to.</param>
            <param name="port">The host port to send the datagram to.</param>
            <exception cref="T:System.ArgumentNullException">
                <i>buffer</i> is null.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">The remote address is unknown, invalid, or unable to be resolved.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The remote port is out of the range of valid values.</exception>
        </member>
        <member name="M:Dart.Sockets.UdpBase.Send(System.Byte[],System.String,System.Int32)">
            <summary>
            Send a datagram to the specified remote address and port.
            </summary>
            <remarks>
                <para>Use the Send method to sent a datagram created from the data contained
            in <i>buffer</i> to the specified <i>hostNameOrAddress</i> and <i>port</i>.</para>
                <para>
            A UDP datagram provides little functionality over an IP datagram, adding a port 
            number field (allows demultiplexing on the receiving host) and a checksum field
            (provides basic error handling).
            Unlike TCP, UDP datagrams are sent as a unit. If Send is called
            3 times to send 3 datagrams to a host, the receiving host will have 
            to call Receive 3 times. Also, the size of each datagram sent will equal
            the size of each datagram received by the receiving host. In addition, since 
            UDP is a connectionless protocol, any datagrams sent to the host are not 
            guaranteed to be delivered. Therefore, any required error checking (outside of UDP's checksum
            implementation) will have to be done by the application-layer protocol.
            </para>
                <para>To send a broadcast datagram, use "255.255.255.255" as the remote address. To send 
            a multicast datagram, use the multicast group address as the remote address after first joining a multicast group by using JoinMulitcastGroup.
            </para>
            </remarks>
            <returns>
            A <see cref="T:Dart.Sockets.Datagram" /> object encapsulating the datagram sent.
            </returns>
            <param name="buffer">A byte array containing the data to send.</param>
            <param name="hostNameOrAddress">The host address (either dot address or hostname) to send the datagram to.</param>
            <param name="port">The host port to send the datagram to.</param>
            <exception cref="T:System.ArgumentNullException">
                <i>buffer</i> is null.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">The remote address is unknown, invalid, or unable to be resolved.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The remote port is out of the range of valid values.</exception>
        </member>
        <member name="M:Dart.Sockets.UdpBase.Send(System.String,System.Net.IPEndPoint)">
            <summary>
            Send a datagram to the specified IPEndPoint.
            </summary>
            <remarks>
                <para>Use the Send method to send a datagram created from the data contained
            in <i>buffer</i> to the specified <i>hostNameOrAddress</i>. <i>buffer</i> is
            converted to a byte array before sending.</para>
                <para>
            A UDP datagram provides little functionality over an IP datagram, adding a port 
            number field (allows demultiplexing on the receiving host) and a checksum field
            (provides basic error handling).
            Unlike TCP, UDP datagrams are sent as a unit. If Send is called
            3 times to send 3 datagrams to a host, the receiving host will have 
            to call Receive 3 times. Also, the size of each datagram sent will equal
            the size of each datagram received by the receiving host. In addition, since 
            UDP is a connectionless protocol, any datagrams sent to the host are not 
            guaranteed to be delivered. Therefore, any required error checking (outside of UDP's checksum
            implementation) will have to be done by the application-layer protocol.
            </para>
                <para>To send a broadcast datagram, use "255.255.255.255" as the remote address. To send 
            a multicast datagram, use the multicast group address as the remote address after first joining a multicast group by using JoinMulitcastGroup.
            </para>
            </remarks>
            <returns>
            A <see cref="T:Dart.Sockets.Datagram" /> object encapsulating the datagram sent.
            </returns>
            <param name="buffer">A string containing the data to send.</param>
            <param name="destination">The <see cref="T:System.Net.IPEndPoint" /> representing the remote hosts's IP address and port.</param>
            <exception cref="T:System.ArgumentNullException">
                <i>buffer</i> is null.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">The remote address is unknown, invalid, or unable to be resolved.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The remote port is out of the range of valid values.</exception>
        </member>
        <member name="M:Dart.Sockets.UdpBase.Send(System.Byte[],System.Net.IPEndPoint)">
            <summary>
            Send a datagram to the specified IPEndPoint.
            </summary>
            <remarks>
                <para>Use the Send method to sent a datagram created from the data contained
            in <i>buffer</i> to the specified <i>hostNameOrAddress</i>.</para>
                <para>
            A UDP datagram provides little functionality over an IP datagram, adding a port 
            number field (allows demultiplexing on the receiving host) and a checksum field
            (provides basic error handling).
            Unlike TCP, UDP datagrams are sent as a unit. If Send is called
            3 times to send 3 datagrams to a host, the receiving host will have 
            to call Receive 3 times. Also, the size of each datagram sent will equal
            the size of each datagram received by the receiving host. In addition, since 
            UDP is a connectionless protocol, any datagrams sent to the host are not 
            guaranteed to be delivered. Therefore, any required error checking (outside of UDP's checksum
            implementation) will have to be done by the application-layer protocol.
            </para>
                <para>To send a broadcast datagram, use "255.255.255.255" as the remote address. To send 
            a multicast datagram, use the multicast group address as the remote address after first joining a multicast group by using JoinMulitcastGroup.
            </para>
            </remarks>
            <returns>
            A <see cref="T:Dart.Sockets.Datagram" /> object encapsulating the datagram sent.
            </returns>
            <param name="buffer">A byte array containing the data to send.</param>
            <param name="destination">The <see cref="T:System.Net.IPEndPoint" /> representing the remote hosts's IP address and port.</param>
            <exception cref="T:System.ArgumentNullException">
                <i>buffer</i> is null.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">The remote address is unknown, invalid, or unable to be resolved.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The remote port is out of the range of valid values.</exception>
        </member>
        <member name="M:Dart.Sockets.UdpBase.SendAsync(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.IPEndPoint,Dart.Sockets.UdpAsyncCallback,System.Object)">
            <summary>
            Send a datagram to the specified IPEndPoint asynchronously, specifying a buffer, offset, length and SocketFlags value.
            </summary>
            <remarks>
                <para>
            Use the SendAsync method to sent a datagram created from the data contained
            in <i>buffer</i> to the specified <i>hostNameOrAddress</i> asynchronously.
            </para>
                <para>
            A UDP datagram provides little functionality over an IP datagram, adding a port 
            number field (allows demultiplexing on the receiving host) and a checksum field
            (provides basic error handling).
            Unlike TCP, UDP datagrams are sent as a unit. If SendAsync is called
            3 times to send 3 datagrams to a host, the receiving host will have 
            to call Receive 3 times. Also, the size of each datagram sent will equal
            the size of each datagram received by the receiving host. In addition, since 
            UDP is a connectionless protocol, any datagrams sent to the host are not 
            guaranteed to be delivered. Therefore, any required error checking (outside of UDP's checksum
            implementation) will have to be done by the application-layer protocol.
            </para>
                <para>To send a broadcast datagram, use "255.255.255.255" as the remote address. To send
            a multicast datagram, use the multicast group address as the remote address after first joining a multicast group by using JoinMulitcastGroup.
            </para>
            </remarks>
            <param name="buffer">A byte array containing the data to send.</param>
            <param name="offset">Starting offset within buffer for sending.</param>
            <param name="count">Number of bytes to send.</param>
            <param name="socketFlags">A bitwise combination of special use sending parameters.</param>
            <param name="destination">The <see cref="T:System.Net.IPEndPoint" /> representing the remote hosts's IP address and port.</param>
            <param name="callback">A <see cref="T:Dart.Sockets.UdpAsyncCallback" /> delegate referencing the method to invoke on an IO completion thread when the operation completes.</param>
            <param name="state">Object to pass into the callback method when the operation completes; can be null.</param>
            <exception cref="T:System.ArgumentNullException">
                <i>buffer</i> is null.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">The remote address is unknown, invalid, or unable to be resolved.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The remote port is out of the range of valid values.<br>--or--</br><I>offset</I> or <I>count</I> is less than 0.</exception>
            <exception cref="T:System.ArgumentException">
                <I>offset</I> + <I>count</I> is greater than the length of <I>buffer</I>.</exception>
        </member>
        <member name="M:Dart.Sockets.UdpBase.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.IPEndPoint)">
            <summary>
            Send a datagram to the specified IPEndPoint, specifying a buffer, offset, length and SocketFlags value.
            </summary>
            <remarks>
                <para>Use the Send method to sent a datagram created from the data contained
            in <i>buffer</i> to the specified <i>hostNameOrAddress</i>.</para>
                <para>
            A UDP datagram provides little functionality over an IP datagram, adding a port 
            number field (allows demultiplexing on the receiving host) and a checksum field
            (provides basic error handling).
            Unlike TCP, UDP datagrams are sent as a unit. If Send is called
            3 times to send 3 datagrams to a host, the receiving host will have 
            to call Receive 3 times. Also, the size of each datagram sent will equal
            the size of each datagram received by the receiving host. In addition, since 
            UDP is a connectionless protocol, any datagrams sent to the host are not 
            guaranteed to be delivered. Therefore, any required error checking (outside of UDP's checksum
            implementation) will have to be done by the application-layer protocol.
            </para>
                <para>To send a broadcast datagram, use "255.255.255.255" as the remote address. To send
            a multicast datagram, use the multicast group address as the remote address after first joining a multicast group by using JoinMulitcastGroup.
            </para>
            </remarks>
            <returns>
            A <see cref="T:Dart.Sockets.Datagram" /> object encapsulating the datagram sent.
            </returns>
            <param name="buffer">A byte array containing the data to send.</param>
            <param name="offset">Starting offset within buffer for sending.</param>
            <param name="count">Number of bytes to send.</param>
            <param name="socketFlags">A bitwise combination of special use sending parameters.</param>
            <param name="destination">The <see cref="T:System.Net.IPEndPoint" /> representing the remote hosts's IP address and port.</param>
            <exception cref="T:System.ArgumentNullException">
                <i>buffer</i> is null.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">The remote address is unknown, invalid, or unable to be resolved.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The remote port is out of the range of valid values.<br>--or--</br><I>offset</I> or <I>count</I> is less than 0.</exception>
            <exception cref="T:System.ArgumentException">
                <I>offset</I> + <I>count</I> is greater than the length of <I>buffer</I>.</exception>
        </member>
        <member name="M:Dart.Sockets.UdpBase.ReceiveTaskAsync(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
            <summary>
            Receive a datagram.
            </summary>
            <param name="buffer">A byte array to be filled with the data received.</param>
            <param name="offset">Location where received bytes are to placed.</param>
            <param name="size">The number of bytes to receive.</param>
            <param name="socketFlags">User specified SocketFlags.</param>
            <remarks>
                <para>
            Use the Receive method to receive a datagram into <i>buffer</i>.
            This method also returns a Datagram object encapsulating
            the datagram received. <see cref="P:Dart.Sockets.Segment.Buffer" /> contains the actual datagram data (equivalent to <i>buffer</i>). 
            <see cref="F:Dart.Sockets.Datagram.Origin" /> contains
            the endpoint of the remote host from which the datagram was sent.
            </para>
                <para>
            A UDP datagram provides little functionality over an IP datagram, adding a port 
            number field (allows demultiplexing on the receiving host) and a checksum field
            (provides basic error handling).
            Unlike TCP, UDP datagrams are sent as a unit. If Send is called
            3 times to send 3 datagrams to a host, the receiving host will have 
            to call Receive 3 times. Also, the size of each datagram sent will equal
            the size of each datagram received by the receiving host. In addition, since 
            UDP is a connectionless protocol, datagrams sent to the host are not 
            guaranteed to be delivered. Therefore, any required error checking (outside of UDP's checksum
            implementation) will have to be done by the application-layer protocol.
            </para>
            </remarks>
            <returns>
            An awaitable task that represents the asynchronous receive operation. The value of the TResult parameter contains the <see cref="T:Dart.Sockets.Datagram">Datagram</see> 
            object encapsulating the received data (null if the socket is closed).
            </returns>
            <exception cref="T:System.ArgumentNullException">
                <i>buffer</i> is null.</exception>
        </member>
        <member name="M:Dart.Sockets.UdpBase.SendTaskAsync(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.IPEndPoint)">
            <summary>
            Send a datagram to the specified IPEndPoint, specifying a buffer, offset, length and SocketFlags value.
            </summary>
            <remarks>
                <para>Use the SendTaskAsync method to send a datagram created from the data contained
            in <i>buffer</i> to the specified <i>hostNameOrAddress</i>.</para>
                <para>
            A UDP datagram provides little functionality over an IP datagram, adding a port 
            number field (allows demultiplexing on the receiving host) and a checksum field
            (provides basic error handling).
            Unlike TCP, UDP datagrams are sent as a unit. If Send is called
            3 times to send 3 datagrams to a host, the receiving host will have 
            to call Receive 3 times. Also, the size of each datagram sent will equal
            the size of each datagram received by the receiving host. In addition, since 
            UDP is a connectionless protocol, any datagrams sent to the host are not 
            guaranteed to be delivered. Therefore, any required error checking (outside of UDP's checksum
            implementation) will have to be done by the application-layer protocol.
            </para>
                <para>To send a broadcast datagram, use "255.255.255.255" as the remote address. To send
            a multicast datagram, use the multicast group address as the remote address after first joining a multicast group by using JoinMulitcastGroup.
            </para>
            </remarks>
            <returns>
            An awaitable task that represents the asynchronous send operation. The value of the TResult parameter contains the <see cref="T:Dart.Sockets.Datagram">Datagram</see> 
            object encapsulating the sent data.
            </returns>
            <param name="buffer">A byte array containing the data to send.</param>
            <param name="offset">Starting offset within buffer for sending.</param>
            <param name="count">Number of bytes to send.</param>
            <param name="socketFlags">A bitwise combination of special use sending parameters.</param>
            <param name="destination">The <see cref="T:System.Net.IPEndPoint" /> representing the remote hosts's IP address and port.</param>
            <exception cref="T:System.ArgumentNullException">
                <i>buffer</i> is null.</exception>
            <exception cref="T:System.Net.Sockets.SocketException">The remote address is unknown, invalid, or unable to be resolved.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The remote port is out of the range of valid values.<br>--or--</br><I>offset</I> or <I>count</I> is less than 0.</exception>
            <exception cref="T:System.ArgumentException">
                <I>offset</I> + <I>count</I> is greater than the length of <I>buffer</I>.</exception>
        </member>
        <member name="P:Dart.Sockets.UdpBase.SocketOption">
            <summary>
            Gets the socket options for classes derived from UdpBase.
            </summary>
        </member>
        <member name="T:Dart.Sockets.UdpSocketOption">
            <summary>
            Contains socket options that may be set by UDP sockets.
            </summary>
        </member>
        <member name="P:Dart.Sockets.UdpSocketOption.AllowBroadcast">
            <summary>
            Gets or sets the ability to send broadcast messages on the socket.
            </summary>
            <value>Defaults to true.</value>
        </member>
        <member name="P:Dart.Sockets.UdpSocketOption.MulticastInterface">
            <summary>
            Gets or sets the host interface to use when sending multicast datagrams.
            </summary>
            <remarks>
                <para>This property is useful if the host has multiple interfaces and you wish to explicitly 
            set the interface to use when sending datagrams to multicast addresses.
            </para>
            </remarks>
            <value>
            The local IPEndPoint that the Udp object is using to send/receive multicasted datagrams.
            </value>
        </member>
        <member name="P:Dart.Sockets.UdpSocketOption.MulticastTimeToLive">
            <summary>
            Gets or sets the IP multicast time-to-live used when datagrams are sent to multicast addresses.
            </summary>
            <remarks>
                <para>
            The MulticastTimeToLive property specifies the number of routers (hops) that multicast 
            datagrams are permitted to pass through before expiring on the network. For each router (hop), 
            this property is decremented by 1. When this property reaches 0, each multicast datagram expires 
            and is no longer forwarded through the network to other subnets.
            </para>
            </remarks>
            <value>
            An integer value representing the time-to-live value used when datagrams are sent to multicast addresses.
            </value>
        </member>
        <member name="T:Dart.Sockets.UdpAsyncCallback">
            <summary>
            References the method to invoke on an IO completion thread when the corresponding asynchronous operation completes.
            </summary>
            <param name="udp">The UdpBase object that initiated the asynchronous operation.</param>
            <param name="datagram">The Datagram object containing received/sent data. Null if the socket is closed.</param>
            <param name="exception">Populated if the operation threw an exception, otherwise null.</param>
            <param name="state">State object passed into the asynchronous call.</param>
        </member>
        <member name="T:Dart.Sockets.ProtocolException">
            <summary>
            Thrown when an upper-layer protocol like FTP, SMTP or POP3 receives a negative response from the server.
            </summary>
            <remarks>This exception is thrown when a server response is negative. For example, 
            if an FTP server returned a "500" respose (indicating a syntax error) to a sent command.</remarks>
        </member>
        <member name="M:Dart.Sockets.ProtocolException.#ctor">
            <summary>
            Initializes a new ProtocolException.
            </summary>
        </member>
        <member name="M:Dart.Sockets.ProtocolException.#ctor(System.String)">
            <summary>
            Initializes a new ProtocolException.
            </summary>
        </member>
        <member name="M:Dart.Sockets.ProtocolException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new ProtocolException.
            </summary>
        </member>
        <member name="M:Dart.Sockets.ProtocolException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new ProtocolException.
            </summary>
        </member>
        <member name="T:Dart.Sockets.Dns">
            <summary>
            Supplements <see cref="T:System.Net.Dns" /> with the ability to retrieve MX records for any email address or mail server.
            Supports socket binding to a specified local IPEndPoint.
            </summary>
            <example>
        The following example demonstrates performing a DNS lookup of a provided hostname, and an MX record lookup of a provided email address.
        <code lang="C#">
        private void button1_Click(object sender, EventArgs e)
        {
            dns1.Start(doMxLookup, EmailToResolveTextbox.Text);
        }

        private void button2_Click(object sender, EventArgs e)
        {
            dns1.Start(doHostLookup, HostToResolveTextbox.Text);
        }

        /// &lt;summary&gt;
        /// Performs an MX record lookup of the provided email address.
        /// &lt;/summary&gt;
        /// &lt;param name="slave"&gt;Object used to perform DNS lookup&lt;/param&gt;
        /// &lt;param name="state"&gt;Passed in from the 2nd parameter of Dns.Start(). Email address to lookup.&lt;/param&gt;
        private void doMxLookup(DnsSlave slave, object state)
        {
            MxHostEntry[] hostEntries = slave.GetMxHostEntries(state.ToString());
            string results = "The following mail servers were returned for " + state.ToString() + ":" + Environment.NewLine;
            foreach (MxHostEntry hostEntry in hostEntries)
                results += hostEntry.HostName + " : Preference: " + hostEntry.Preference.ToString() + Environment.NewLine;
            //Marshal result to the UI for display
            dns1.Marshal(results, null);
        }

        /// &lt;summary&gt;
        /// Performs a DNS lookup of the provided hostname.
        /// &lt;/summary&gt;
        /// &lt;param name="slave"&gt;Object used to perform DNS lookup&lt;/param&gt;
        /// &lt;param name="state"&gt;Passed in from the 2nd parameter of Dns.Start(). Hostname to lookup.&lt;/param&gt;
        private void doHostLookup(DnsSlave slave, object state)
        {
            System.Net.IPHostEntry hostEntry = slave.GetHostEntry(state.ToString());
            string results = "The following IP addresses were returned for " + state.ToString() + ":" + Environment.NewLine;
            foreach (System.Net.IPAddress address in hostEntry.AddressList)
                results += address.ToString() + Environment.NewLine;
            //Marshal result to the UI for display
            dns1.Marshal(results, null);
        }

        /// &lt;summary&gt;
        /// Raised when Dns.Marshal(string, object) is called.
        /// &lt;/summary&gt;
        private void dns1_UserState(object sender, UserStateEventArgs e)
        {
            textBox1.AppendText(e.Message + Environment.NewLine);
        }
        </code><code lang="VB">
        Private Sub button1_Click(ByVal sender As Object, ByVal e As EventArgs)
            dns1.Start(AddressOf doMxLookup, EmailToResolveTextbox.Text)
        End Sub

        Private Sub button2_Click(ByVal sender As Object, ByVal e As EventArgs)
            dns1.Start(AddressOf doHostLookup, HostToResolveTextbox.Text)
        End Sub

        ''' &lt;summary&gt;
        ''' Performs an MX record lookup of the provided email address.
        ''' &lt;/summary&gt;
        ''' &lt;param name="slave"&gt;Object used to perform DNS lookup&lt;/param&gt;
        ''' &lt;param name="state"&gt;Passed in from the 2nd parameter of Dns.Start(). Email address to lookup.&lt;/param&gt;
        Private Sub doMxLookup(ByVal slave As DnsSlave, ByVal state As Object)
            Dim hostEntries() As MxHostEntry = slave.GetMxHostEntries(state.ToString())
            Dim results As String = "The following mail servers were returned for " &amp; state.ToString() &amp; ":" &amp; Environment.NewLine
            For Each hostEntry As MxHostEntry In hostEntries
                results &amp;= hostEntry.HostName &amp; " : Preference: " &amp; hostEntry.Preference.ToString() &amp; Environment.NewLine
            Next hostEntry
            'Marshal result to the UI for display
            dns1.Marshal(results, Nothing)
        End Sub

        ''' &lt;summary&gt;
        ''' Performs a DNS lookup of the provided hostname.
        ''' &lt;/summary&gt;
        ''' &lt;param name="slave"&gt;Object used to perform DNS lookup&lt;/param&gt;
        ''' &lt;param name="state"&gt;Passed in from the 2nd parameter of Dns.Start(). Hostname to lookup.&lt;/param&gt;
        Private Sub doHostLookup(ByVal slave As DnsSlave, ByVal state As Object)
            Dim hostEntry As System.Net.IPHostEntry = slave.GetHostEntry(state.ToString())
            Dim results As String = "The following IP addresses were returned for " &amp; state.ToString() &amp; ":" &amp; Environment.NewLine
            For Each address As System.Net.IPAddress In hostEntry.AddressList
                results &amp;= address.ToString() &amp; Environment.NewLine
            Next address
            'Marshal result to the UI for display
            dns1.Marshal(results, Nothing)
        End Sub

        ''' &lt;summary&gt;
        ''' Raised when Dns.Marshal(string, object) is called.
        ''' &lt;/summary&gt;
        Private Sub dns1_UserState(ByVal sender As Object, ByVal e As UserStateEventArgs)
            textBox1.AppendText(e.Message &amp; Environment.NewLine)
        End Sub
        </code></example>
        </member>
        <member name="F:Dart.Sockets.Dns.DefaultPort">
            <summary>
            The default DNS server port; 53.
            </summary>
        </member>
        <member name="M:Dart.Sockets.Dns.#ctor">
            <summary>
            Default constructor for Dns class.
            </summary>
        </member>
        <member name="M:Dart.Sockets.Dns.#ctor(System.ComponentModel.IContainer)">
            <summary>
            Initializes a new Dns object.
            </summary>
            <param name="container">The IContainer which contains the object.</param>
        </member>
        <member name="M:Dart.Sockets.Dns.Start(Dart.Sockets.DnsThreadStart,System.Object)">
            <summary>
            Starts a worker thread on which the specified delegate method executes.  
            </summary>
            <param name="worker">
                <see cref="T:Dart.Sockets.DnsThreadStart" /> delegate specifies the method to execute.</param>
            <param name="state">Information to pass to the worker delegate method; can be null.</param>
            <remarks>
                <para>
                This method provides an easy means for executing multiple DNS resolutions in parallel. The
                default IPv4 socket interface is used.
                </para>
                <para>
                Unhandled exceptions occurring on the worker thread are reported via the 
                <see cref="E:Dart.Sockets.ComponentBase.Error">Error</see> event.
                </para>
            </remarks>
            <example>
        The following example demonstrates performing a DNS lookup of a provided hostname, and an MX record lookup of a provided email address.
        <code lang="C#">
        private void button1_Click(object sender, EventArgs e)
        {
            dns1.Start(doMxLookup, EmailToResolveTextbox.Text);
        }

        private void button2_Click(object sender, EventArgs e)
        {
            dns1.Start(doHostLookup, HostToResolveTextbox.Text);
        }

        /// &lt;summary&gt;
        /// Performs an MX record lookup of the provided email address.
        /// &lt;/summary&gt;
        /// &lt;param name="slave"&gt;Object used to perform DNS lookup&lt;/param&gt;
        /// &lt;param name="state"&gt;Passed in from the 2nd parameter of Dns.Start(). Email address to lookup.&lt;/param&gt;
        private void doMxLookup(DnsSlave slave, object state)
        {
            MxHostEntry[] hostEntries = slave.GetMxHostEntries(state.ToString());
            string results = "The following mail servers were returned for " + state.ToString() + ":" + Environment.NewLine;
            foreach (MxHostEntry hostEntry in hostEntries)
                results += hostEntry.HostName + " : Preference: " + hostEntry.Preference.ToString() + Environment.NewLine;
            //Marshal result to the UI for display
            dns1.Marshal(results, null);
        }

        /// &lt;summary&gt;
        /// Performs a DNS lookup of the provided hostname.
        /// &lt;/summary&gt;
        /// &lt;param name="slave"&gt;Object used to perform DNS lookup&lt;/param&gt;
        /// &lt;param name="state"&gt;Passed in from the 2nd parameter of Dns.Start(). Hostname to lookup.&lt;/param&gt;
        private void doHostLookup(DnsSlave slave, object state)
        {
            System.Net.IPHostEntry hostEntry = slave.GetHostEntry(state.ToString());
            string results = "The following IP addresses were returned for " + state.ToString() + ":" + Environment.NewLine;
            foreach (System.Net.IPAddress address in hostEntry.AddressList)
                results += address.ToString() + Environment.NewLine;
            //Marshal result to the UI for display
            dns1.Marshal(results, null);
        }

        /// &lt;summary&gt;
        /// Raised when Dns.Marshal(string, object) is called.
        /// &lt;/summary&gt;
        private void dns1_UserState(object sender, UserStateEventArgs e)
        {
            textBox1.AppendText(e.Message + Environment.NewLine);
        }
        </code><code lang="VB">
        Private Sub button1_Click(ByVal sender As Object, ByVal e As EventArgs)
            dns1.Start(AddressOf doMxLookup, EmailToResolveTextbox.Text)
        End Sub

        Private Sub button2_Click(ByVal sender As Object, ByVal e As EventArgs)
            dns1.Start(AddressOf doHostLookup, HostToResolveTextbox.Text)
        End Sub

        ''' &lt;summary&gt;
        ''' Performs an MX record lookup of the provided email address.
        ''' &lt;/summary&gt;
        ''' &lt;param name="slave"&gt;Object used to perform DNS lookup&lt;/param&gt;
        ''' &lt;param name="state"&gt;Passed in from the 2nd parameter of Dns.Start(). Email address to lookup.&lt;/param&gt;
        Private Sub doMxLookup(ByVal slave As DnsSlave, ByVal state As Object)
            Dim hostEntries() As MxHostEntry = slave.GetMxHostEntries(state.ToString())
            Dim results As String = "The following mail servers were returned for " &amp; state.ToString() &amp; ":" &amp; Environment.NewLine
            For Each hostEntry As MxHostEntry In hostEntries
                results &amp;= hostEntry.HostName &amp; " : Preference: " &amp; hostEntry.Preference.ToString() &amp; Environment.NewLine
            Next hostEntry
            'Marshal result to the UI for display
            dns1.Marshal(results, Nothing)
        End Sub

        ''' &lt;summary&gt;
        ''' Performs a DNS lookup of the provided hostname.
        ''' &lt;/summary&gt;
        ''' &lt;param name="slave"&gt;Object used to perform DNS lookup&lt;/param&gt;
        ''' &lt;param name="state"&gt;Passed in from the 2nd parameter of Dns.Start(). Hostname to lookup.&lt;/param&gt;
        Private Sub doHostLookup(ByVal slave As DnsSlave, ByVal state As Object)
            Dim hostEntry As System.Net.IPHostEntry = slave.GetHostEntry(state.ToString())
            Dim results As String = "The following IP addresses were returned for " &amp; state.ToString() &amp; ":" &amp; Environment.NewLine
            For Each address As System.Net.IPAddress In hostEntry.AddressList
                results &amp;= address.ToString() &amp; Environment.NewLine
            Next address
            'Marshal result to the UI for display
            dns1.Marshal(results, Nothing)
        End Sub

        ''' &lt;summary&gt;
        ''' Raised when Dns.Marshal(string, object) is called.
        ''' &lt;/summary&gt;
        Private Sub dns1_UserState(ByVal sender As Object, ByVal e As UserStateEventArgs)
            textBox1.AppendText(e.Message &amp; Environment.NewLine)
        End Sub
        </code></example>
        </member>
        <member name="M:Dart.Sockets.Dns.Start(Dart.Sockets.DnsThreadStart,Dart.Sockets.IPEndPoint,System.Object)">
            <summary>
            Starts a worker thread on which the specified delegate method executes.  
            </summary>
            <param name="worker">
                <see cref="T:Dart.Sockets.DnsThreadStart" /> delegate specifies the method to execute.</param>
            <param name="localEndPoint">Specifies the local IPEndPoint to bind to.</param>
            <param name="state">Information to pass to the worker delegate method; can be null.</param>
            <remarks>
                <para>
                This method provides an easy means for executing multiple DNS resolutions in parallel. 
                </para>
                <para>
                Unhandled exceptions occurring on the worker thread are reported via the 
                <see cref="E:Dart.Sockets.ComponentBase.Error">Error</see> event.
                </para>
            </remarks>
        </member>
        <member name="P:Dart.Sockets.Dns.Servers">
            <summary>
            A list of DNS servers known to the local system.
            </summary>
        </member>
        <member name="T:Dart.Sockets.DnsSlave">
            <summary>
            Used to perform DNS resolutions.
            </summary>
        </member>
        <member name="F:Dart.Sockets.DnsSlave.Socket">
            <summary>
            Gets the socket used for communications.
            </summary>
            <value>The <see cref="T:System.Net.Sockets.Socket">Socket</see> used for UDP communications.</value>
        </member>
        <member name="M:Dart.Sockets.DnsSlave.#ctor(Dart.Sockets.Dns,Dart.Sockets.IPEndPoint)">
            <summary>
            Creates an object that manages DNS resolution requests.
            </summary>
            <param name="parent">Parent Dns component.</param>
            <param name="localEndPoint">A IPEndPoint that establishes from which IP interface requests will originate.</param>
            <remarks>The IPAddress.AddressFamily of the local EndPoint MUST match the AddressFamily of destination hosts.</remarks>
        </member>
        <member name="M:Dart.Sockets.DnsSlave.GetMxHostEntries(System.String)">
            <summary>
            Resolves an emailAddress or mail server domain using the default DNS server.
            </summary>
            <param name="emailAddress">Email address (or domain server name).</param>
            <remarks>Any email address must be in the standard user@hostname form.</remarks>
            <returns>An array of <see cref="T:Dart.Sockets.MxHostEntry" /> objects associated with the email address.</returns>
            <example>
        The following example demonstrates performing a DNS lookup of a provided hostname, and an MX record lookup of a provided email address.
        <code lang="C#">
        private void button1_Click(object sender, EventArgs e)
        {
            dns1.Start(doMxLookup, EmailToResolveTextbox.Text);
        }

        private void button2_Click(object sender, EventArgs e)
        {
            dns1.Start(doHostLookup, HostToResolveTextbox.Text);
        }

        /// &lt;summary&gt;
        /// Performs an MX record lookup of the provided email address.
        /// &lt;/summary&gt;
        /// &lt;param name="slave"&gt;Object used to perform DNS lookup&lt;/param&gt;
        /// &lt;param name="state"&gt;Passed in from the 2nd parameter of Dns.Start(). Email address to lookup.&lt;/param&gt;
        private void doMxLookup(DnsSlave slave, object state)
        {
            MxHostEntry[] hostEntries = slave.GetMxHostEntries(state.ToString());
            string results = "The following mail servers were returned for " + state.ToString() + ":" + Environment.NewLine;
            foreach (MxHostEntry hostEntry in hostEntries)
                results += hostEntry.HostName + " : Preference: " + hostEntry.Preference.ToString() + Environment.NewLine;
            //Marshal result to the UI for display
            dns1.Marshal(results, null);
        }

        /// &lt;summary&gt;
        /// Performs a DNS lookup of the provided hostname.
        /// &lt;/summary&gt;
        /// &lt;param name="slave"&gt;Object used to perform DNS lookup&lt;/param&gt;
        /// &lt;param name="state"&gt;Passed in from the 2nd parameter of Dns.Start(). Hostname to lookup.&lt;/param&gt;
        private void doHostLookup(DnsSlave slave, object state)
        {
            System.Net.IPHostEntry hostEntry = slave.GetHostEntry(state.ToString());
            string results = "The following IP addresses were returned for " + state.ToString() + ":" + Environment.NewLine;
            foreach (System.Net.IPAddress address in hostEntry.AddressList)
                results += address.ToString() + Environment.NewLine;
            //Marshal result to the UI for display
            dns1.Marshal(results, null);
        }

        /// &lt;summary&gt;
        /// Raised when Dns.Marshal(string, object) is called.
        /// &lt;/summary&gt;
        private void dns1_UserState(object sender, UserStateEventArgs e)
        {
            textBox1.AppendText(e.Message + Environment.NewLine);
        }
        </code><code lang="VB">
        Private Sub button1_Click(ByVal sender As Object, ByVal e As EventArgs)
            dns1.Start(AddressOf doMxLookup, EmailToResolveTextbox.Text)
        End Sub

        Private Sub button2_Click(ByVal sender As Object, ByVal e As EventArgs)
            dns1.Start(AddressOf doHostLookup, HostToResolveTextbox.Text)
        End Sub

        ''' &lt;summary&gt;
        ''' Performs an MX record lookup of the provided email address.
        ''' &lt;/summary&gt;
        ''' &lt;param name="slave"&gt;Object used to perform DNS lookup&lt;/param&gt;
        ''' &lt;param name="state"&gt;Passed in from the 2nd parameter of Dns.Start(). Email address to lookup.&lt;/param&gt;
        Private Sub doMxLookup(ByVal slave As DnsSlave, ByVal state As Object)
            Dim hostEntries() As MxHostEntry = slave.GetMxHostEntries(state.ToString())
            Dim results As String = "The following mail servers were returned for " &amp; state.ToString() &amp; ":" &amp; Environment.NewLine
            For Each hostEntry As MxHostEntry In hostEntries
                results &amp;= hostEntry.HostName &amp; " : Preference: " &amp; hostEntry.Preference.ToString() &amp; Environment.NewLine
            Next hostEntry
            'Marshal result to the UI for display
            dns1.Marshal(results, Nothing)
        End Sub

        ''' &lt;summary&gt;
        ''' Performs a DNS lookup of the provided hostname.
        ''' &lt;/summary&gt;
        ''' &lt;param name="slave"&gt;Object used to perform DNS lookup&lt;/param&gt;
        ''' &lt;param name="state"&gt;Passed in from the 2nd parameter of Dns.Start(). Hostname to lookup.&lt;/param&gt;
        Private Sub doHostLookup(ByVal slave As DnsSlave, ByVal state As Object)
            Dim hostEntry As System.Net.IPHostEntry = slave.GetHostEntry(state.ToString())
            Dim results As String = "The following IP addresses were returned for " &amp; state.ToString() &amp; ":" &amp; Environment.NewLine
            For Each address As System.Net.IPAddress In hostEntry.AddressList
                results &amp;= address.ToString() &amp; Environment.NewLine
            Next address
            'Marshal result to the UI for display
            dns1.Marshal(results, Nothing)
        End Sub

        ''' &lt;summary&gt;
        ''' Raised when Dns.Marshal(string, object) is called.
        ''' &lt;/summary&gt;
        Private Sub dns1_UserState(ByVal sender As Object, ByVal e As UserStateEventArgs)
            textBox1.AppendText(e.Message &amp; Environment.NewLine)
        End Sub
        </code></example>
        </member>
        <member name="M:Dart.Sockets.DnsSlave.GetMxHostEntries(System.String,Dart.Sockets.IPEndPoint)">
            <summary>
            Resolves an emailAddress or mail server using the specified DNS server.
            </summary>
            <param name="emailAddress">Email address (or domain server name).</param>
            <param name="remoteEndPoint">
                <see>IPEndPoint</see> that specifies the DNS server.</param>
            <remarks>
                <para>Any email address must be in the standard user@hostname form.</para>
            </remarks>
            <returns>An array of <see cref="T:Dart.Sockets.MxHostEntry" /> objects associated with the email address.</returns>
        </member>
        <member name="M:Dart.Sockets.DnsSlave.GetHostEntry(System.String)">
            <summary>
            Resolves a hostname (forward lookup) or IP address (reverse lookup) using the default DNS server.
            </summary>
            <param name="hostNameOrAddress">Hostname or IP address (IPAddress.ToString() can be used).</param>
            <returns>A <see cref="T:System.Net.IPHostEntry" />.</returns>
            <remarks>If IPv6 resolution results in an exception, it will only be thrown if IPv4 resolution succeeded but returned no records.</remarks>
        </member>
        <member name="M:Dart.Sockets.DnsSlave.GetHostEntry(System.String,Dart.Sockets.IPEndPoint)">
            <summary>
            Resolves a hostname (forward lookup) or IP address (reverse lookup) using the specified DNS server.
            </summary>
            <param name="hostNameOrAddress">Hostname or IP address (IPAddress.ToString() can be used).</param>
            <param name="remoteEndPoint">
                <see>IPEndPoint</see> that specifies the DNS server.</param>
            <returns>A <see cref="T:System.Net.IPHostEntry" />.</returns>
            <remarks>If IPv6 resolution results in an exception, it will only be thrown if IPv4 resolution succeeded but returned no records.</remarks>
        </member>
        <member name="T:Dart.Sockets.MxHostEntry">
            <summary>
            Provides the HostName and Preference provided by an MX record lookup.
            </summary>
            <example>
        The following example demonstrates performing a DNS lookup of a provided hostname, and an MX record lookup of a provided email address.
        <code lang="C#">
        private void button1_Click(object sender, EventArgs e)
        {
            dns1.Start(doMxLookup, EmailToResolveTextbox.Text);
        }

        private void button2_Click(object sender, EventArgs e)
        {
            dns1.Start(doHostLookup, HostToResolveTextbox.Text);
        }

        /// &lt;summary&gt;
        /// Performs an MX record lookup of the provided email address.
        /// &lt;/summary&gt;
        /// &lt;param name="slave"&gt;Object used to perform DNS lookup&lt;/param&gt;
        /// &lt;param name="state"&gt;Passed in from the 2nd parameter of Dns.Start(). Email address to lookup.&lt;/param&gt;
        private void doMxLookup(DnsSlave slave, object state)
        {
            MxHostEntry[] hostEntries = slave.GetMxHostEntries(state.ToString());
            string results = "The following mail servers were returned for " + state.ToString() + ":" + Environment.NewLine;
            foreach (MxHostEntry hostEntry in hostEntries)
                results += hostEntry.HostName + " : Preference: " + hostEntry.Preference.ToString() + Environment.NewLine;
            //Marshal result to the UI for display
            dns1.Marshal(results, null);
        }

        /// &lt;summary&gt;
        /// Performs a DNS lookup of the provided hostname.
        /// &lt;/summary&gt;
        /// &lt;param name="slave"&gt;Object used to perform DNS lookup&lt;/param&gt;
        /// &lt;param name="state"&gt;Passed in from the 2nd parameter of Dns.Start(). Hostname to lookup.&lt;/param&gt;
        private void doHostLookup(DnsSlave slave, object state)
        {
            System.Net.IPHostEntry hostEntry = slave.GetHostEntry(state.ToString());
            string results = "The following IP addresses were returned for " + state.ToString() + ":" + Environment.NewLine;
            foreach (System.Net.IPAddress address in hostEntry.AddressList)
                results += address.ToString() + Environment.NewLine;
            //Marshal result to the UI for display
            dns1.Marshal(results, null);
        }

        /// &lt;summary&gt;
        /// Raised when Dns.Marshal(string, object) is called.
        /// &lt;/summary&gt;
        private void dns1_UserState(object sender, UserStateEventArgs e)
        {
            textBox1.AppendText(e.Message + Environment.NewLine);
        }
        </code><code lang="VB">
        Private Sub button1_Click(ByVal sender As Object, ByVal e As EventArgs)
            dns1.Start(AddressOf doMxLookup, EmailToResolveTextbox.Text)
        End Sub

        Private Sub button2_Click(ByVal sender As Object, ByVal e As EventArgs)
            dns1.Start(AddressOf doHostLookup, HostToResolveTextbox.Text)
        End Sub

        ''' &lt;summary&gt;
        ''' Performs an MX record lookup of the provided email address.
        ''' &lt;/summary&gt;
        ''' &lt;param name="slave"&gt;Object used to perform DNS lookup&lt;/param&gt;
        ''' &lt;param name="state"&gt;Passed in from the 2nd parameter of Dns.Start(). Email address to lookup.&lt;/param&gt;
        Private Sub doMxLookup(ByVal slave As DnsSlave, ByVal state As Object)
            Dim hostEntries() As MxHostEntry = slave.GetMxHostEntries(state.ToString())
            Dim results As String = "The following mail servers were returned for " &amp; state.ToString() &amp; ":" &amp; Environment.NewLine
            For Each hostEntry As MxHostEntry In hostEntries
                results &amp;= hostEntry.HostName &amp; " : Preference: " &amp; hostEntry.Preference.ToString() &amp; Environment.NewLine
            Next hostEntry
            'Marshal result to the UI for display
            dns1.Marshal(results, Nothing)
        End Sub

        ''' &lt;summary&gt;
        ''' Performs a DNS lookup of the provided hostname.
        ''' &lt;/summary&gt;
        ''' &lt;param name="slave"&gt;Object used to perform DNS lookup&lt;/param&gt;
        ''' &lt;param name="state"&gt;Passed in from the 2nd parameter of Dns.Start(). Hostname to lookup.&lt;/param&gt;
        Private Sub doHostLookup(ByVal slave As DnsSlave, ByVal state As Object)
            Dim hostEntry As System.Net.IPHostEntry = slave.GetHostEntry(state.ToString())
            Dim results As String = "The following IP addresses were returned for " &amp; state.ToString() &amp; ":" &amp; Environment.NewLine
            For Each address As System.Net.IPAddress In hostEntry.AddressList
                results &amp;= address.ToString() &amp; Environment.NewLine
            Next address
            'Marshal result to the UI for display
            dns1.Marshal(results, Nothing)
        End Sub

        ''' &lt;summary&gt;
        ''' Raised when Dns.Marshal(string, object) is called.
        ''' &lt;/summary&gt;
        Private Sub dns1_UserState(ByVal sender As Object, ByVal e As UserStateEventArgs)
            textBox1.AppendText(e.Message &amp; Environment.NewLine)
        End Sub
        </code></example>
        </member>
        <member name="M:Dart.Sockets.MxHostEntry.#ctor(System.String,System.Int32)">
            <summary>
            Constructor for MxHostEntry.
            </summary>
        </member>
        <member name="F:Dart.Sockets.MxHostEntry.Preference">
            <summary>
            Gets the preference value of the entry.
            </summary>
            <remarks>
            Lower numbers are preferred.
            </remarks>
        </member>
        <member name="F:Dart.Sockets.MxHostEntry.HostName">
            <summary>
            Gets the hostname of the resolved mail server.
            </summary>
        </member>
        <member name="T:Dart.Sockets.DnsThreadStart">
            <summary>
            Represents the method that will execute on a worker thread when <see cref="M:Dart.Sockets.Dns.Start(Dart.Sockets.DnsThreadStart,Dart.Sockets.IPEndPoint,System.Object)">Start</see> is used. 
            </summary>
            <param name="slave">The DnsSlave object that is independent of all other worker threads.</param>
            <param name="state">Any additional information provided by the user.</param>
        </member>
        <member name="T:Dart.Sockets.Ping">
            <summary>
            Provides classes and methods for Pinging (sending ICMP Echo requests).
            </summary>
            <example>
        The following example demonstrates pinging a remote host.
        <code lang="C#">
        private void button1_Click(object sender, EventArgs e)
        {
            ping1.Start(pingWorker, HostNameOrAddressToPingTextbox.Text);
        }

        private void pingWorker(PingSlave slave, object state)
        {
            ping1.Marshal(slave.GetEchoes(new Dart.Sockets.IPEndPoint(state.ToString(), 0).Address, null, 20, 5000, false));
        }

        void ping1_Echo(object sender, EchoEventArgs e)
        {
            string results = "The following echoes were returned:\r\n";
            for (int i = 0; i &lt; e.Echoes.Length; i++)
                results += e.Echoes[i].ToString() + "\r\n";
            textBox1.AppendText(results);
        }
        </code><code lang="VB">
        Private Sub button1_Click(ByVal sender As Object, ByVal e As EventArgs)
            ping1.Start(AddressOf pingWorker, HostNameOrAddressToPingTextbox.Text)
        End Sub

        Private Sub pingWorker(ByVal slave As PingSlave, ByVal state As Object)
            ping1.Marshal(slave.GetEchoes((New Dart.Sockets.IPEndPoint(state.ToString(), 0)).Address, Nothing, 20, 5000, False))
        End Sub

        Private Sub ping1_Echo(ByVal sender As Object, ByVal e As EchoEventArgs)
            Dim results As String = "The following echoes were returned:" &amp; vbCrLf
            For i As Integer = 0 To e.Echoes.Length - 1
                results &amp;= e.Echoes(i).ToString() &amp; vbCrLf
            Next i
            textBox1.AppendText(results)
        End Sub
        </code></example>
        </member>
        <member name="M:Dart.Sockets.Ping.#ctor(System.ComponentModel.IContainer)">
            <summary>
            Initializes a new Ping object.
            </summary>
            <param name="container">The IContainer which contains the object.</param>
        </member>
        <member name="M:Dart.Sockets.Ping.#ctor">
            <summary>
            Create a Ping component.
            </summary>
        </member>
        <member name="M:Dart.Sockets.Ping.Start(Dart.Sockets.PingThreadStart,System.Object)">
            <summary>
            Starts a worker thread on which the specified delegate function executes.
            </summary>
            <param name="worker">PingThreadStart delegate specifying the function to execute.</param>
            <param name="state">Information to pass to the worker delegate function; can be null.</param>
            <remarks>
                <para>
                This method provides a convenient means for executing blocking functions on a worker thread. 
                Applications with a UI thread should use this technique to execute processes (like multiple Pings) that can block the UI thread.
                </para>
                <para>
                The local IP interface defaults to IPAddress.Any and the Ping.Type defaults to Ping.Type.Raw.
                </para>
                <para>
                Unhandled exceptions occurring on the worker thread will be caught and reported by the <see cref="E:Dart.Sockets.ComponentBase.Error">Error</see> event.
                </para>
            </remarks>
            <example>
        The following example demonstrates pinging a remote host.
        <code lang="C#">
        private void button1_Click(object sender, EventArgs e)
        {
            ping1.Start(pingWorker, HostNameOrAddressToPingTextbox.Text);
        }

        private void pingWorker(PingSlave slave, object state)
        {
            ping1.Marshal(slave.GetEchoes(new Dart.Sockets.IPEndPoint(state.ToString(), 0).Address, null, 20, 5000, false));
        }

        void ping1_Echo(object sender, EchoEventArgs e)
        {
            string results = "The following echoes were returned:\r\n";
            for (int i = 0; i &lt; e.Echoes.Length; i++)
                results += e.Echoes[i].ToString() + "\r\n";
            textBox1.AppendText(results);
        }
        </code><code lang="VB">
        Private Sub button1_Click(ByVal sender As Object, ByVal e As EventArgs)
            ping1.Start(AddressOf pingWorker, HostNameOrAddressToPingTextbox.Text)
        End Sub

        Private Sub pingWorker(ByVal slave As PingSlave, ByVal state As Object)
            ping1.Marshal(slave.GetEchoes((New Dart.Sockets.IPEndPoint(state.ToString(), 0)).Address, Nothing, 20, 5000, False))
        End Sub

        Private Sub ping1_Echo(ByVal sender As Object, ByVal e As EchoEventArgs)
            Dim results As String = "The following echoes were returned:" &amp; vbCrLf
            For i As Integer = 0 To e.Echoes.Length - 1
                results &amp;= e.Echoes(i).ToString() &amp; vbCrLf
            Next i
            textBox1.AppendText(results)
        End Sub
        </code></example>
        </member>
        <member name="M:Dart.Sockets.Ping.Start(Dart.Sockets.PingThreadStart,System.Net.IPAddress,Dart.Sockets.Ping.Type,System.Object)">
            <summary>
            Starts a worker thread on which the specified delegate function executes.  
            </summary>
            <param name="worker">PingThreadStart delegate specifying the function to execute.</param>
            <param name="localAddress">The local IP interface desired.</param>
            <param name="type">The <see cref="T:Dart.Sockets.Ping.Type" /> of Echo technology desired.</param>
            <param name="state">Information to pass to the worker delegate function; can be null.</param>
            <remarks>
                <para>
                This method provides a convenient means for executing blocking functions on a worker thread. 
                Applications with a UI thread should use this technique to execute processes (like multiple Pings) that can block the UI thread.
                </para>
                <para>
                Unhandled exceptions occurring on the worker thread will be caught and reported by the <see cref="E:Dart.Sockets.ComponentBase.Error">Error</see> event.
                </para>
            </remarks>
        </member>
        <member name="M:Dart.Sockets.Ping.Marshal(Dart.Sockets.Echo[])">
            <summary>
            Marshals an array of Echo objects to the UI thread.
            </summary>
            <param name="echoes">The Echo objects to be marshaled.</param>
            <remarks>
                <para>
                This method is used to marshal Ping echoes from a worker thread to the UI thread for typical display purposes.  
                It calls the <see cref="M:Dart.Sockets.Ping.OnEcho(Dart.Sockets.EchoEventArgs)" /> method, which raises the <see cref="E:Dart.Sockets.Ping.Echo">Echo</see> event.
                </para>
                <para>
                See the <see cref="P:Dart.Sockets.ComponentBase.SynchronizingObject">SynchronizingObject</see> property for information on 
                updating UI controls in your event handler.
                </para>
            </remarks>
            <example>
        The following example demonstrates pinging a remote host.
        <code lang="C#">
        private void button1_Click(object sender, EventArgs e)
        {
            ping1.Start(pingWorker, HostNameOrAddressToPingTextbox.Text);
        }

        private void pingWorker(PingSlave slave, object state)
        {
            ping1.Marshal(slave.GetEchoes(new Dart.Sockets.IPEndPoint(state.ToString(), 0).Address, null, 20, 5000, false));
        }

        void ping1_Echo(object sender, EchoEventArgs e)
        {
            string results = "The following echoes were returned:\r\n";
            for (int i = 0; i &lt; e.Echoes.Length; i++)
                results += e.Echoes[i].ToString() + "\r\n";
            textBox1.AppendText(results);
        }
        </code><code lang="VB">
        Private Sub button1_Click(ByVal sender As Object, ByVal e As EventArgs)
            ping1.Start(AddressOf pingWorker, HostNameOrAddressToPingTextbox.Text)
        End Sub

        Private Sub pingWorker(ByVal slave As PingSlave, ByVal state As Object)
            ping1.Marshal(slave.GetEchoes((New Dart.Sockets.IPEndPoint(state.ToString(), 0)).Address, Nothing, 20, 5000, False))
        End Sub

        Private Sub ping1_Echo(ByVal sender As Object, ByVal e As EchoEventArgs)
            Dim results As String = "The following echoes were returned:" &amp; vbCrLf
            For i As Integer = 0 To e.Echoes.Length - 1
                results &amp;= e.Echoes(i).ToString() &amp; vbCrLf
            Next i
            textBox1.AppendText(results)
        End Sub
        </code></example>
        </member>
        <member name="M:Dart.Sockets.Ping.OnEcho(Dart.Sockets.EchoEventArgs)">
            <summary>
            Raises the <see cref="E:Dart.Sockets.Ping.Echo" /> event.
            </summary>
            <param name="e">An <see cref="T:Dart.Sockets.EchoEventArgs">EchoEventArgs</see> object that contains the event data.</param>
            <remarks>
            If the Synchronizing property is set, this method asynchronously invokes the <see cref="E:Dart.Sockets.Ping.Echo" /> event on the UI thread.
            If the Synchronizing property is null, this method invokes the event on the executing thread.
            <para>
            This method allows derived classes to handle the event without attaching a delegate, but marshaling is not provided.
            This is the preferred technique for handling the event in a derived class.
            </para><para><b>Note to Inheritors:</b> When overriding OnEcho in a derived class, 
            be sure to call the base class OnEcho method, so that registered delegates receive the event. 
            </para><para>
            See the <see cref="P:Dart.Sockets.ComponentBase.SynchronizingObject">SynchronizingObject</see> property for information on 
            updating UI controls in your event handler.
            </para></remarks>
        </member>
        <member name="E:Dart.Sockets.Ping.Echo">
            <summary>
            Raised when <see cref="M:Dart.Sockets.Ping.Marshal(Dart.Sockets.Echo[])" /> is used.
            </summary>
            <remarks>
                See the <see cref="P:Dart.Sockets.ComponentBase.SynchronizingObject">SynchronizingObject</see> property for information on 
                updating UI controls in your event handler.
            </remarks>
        </member>
        <member name="T:Dart.Sockets.Ping.Type">
            <summary>
            Controls the software technology used to create the Ping.
            </summary>
            <remarks>
            Ping broadcasting is only supported under Raw. When using System, only the first responding system is returned.
            </remarks>
        </member>
        <member name="F:Dart.Sockets.Ping.Type.System">
            <summary>
            The system icmp.dll will be used to generate and receive the Ping.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Ping.Type.Raw">
            <summary>
            A raw socket will be created to send and receive the ping. Administrator privileges may be required. Supports broadcasting.
            </summary>
        </member>
        <member name="T:Dart.Sockets.Ping.Status">
            <summary>
            Enumerates the status of the ICMP echo request.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Ping.Status.Success">
            <summary>
            Request succeeded.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Ping.Status.BufferTooSmall">
            <summary>
            Reply buffer was too small.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Ping.Status.NetworkUnreachable">
            <summary>
            Destination netword was unreachable.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Ping.Status.HostUnreachable">
            <summary>
            Destination host was unreachable.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Ping.Status.ProtocolUnreachable">
            <summary>
            Destination protocol was unreachable.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Ping.Status.PortUnreachable">
            <summary>
            Destination port was unreachable.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Ping.Status.NoResources">
            <summary>
            Insufficient IP resources were available.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Ping.Status.BadIpOption">
            <summary>
            A bad IP option was specified.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Ping.Status.HardwareError">
            <summary>
            A hardware error occurred.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Ping.Status.PacketTooBig">
            <summary>
            The packet was too big.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Ping.Status.RequestTimedOut">
            <summary>
            Request timed out.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Ping.Status.BadRequest">
            <summary>
            Bad request.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Ping.Status.BadRoute">
            <summary>
            Bad route.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Ping.Status.TtlExpiredTransit">
            <summary>
            The time to live (ttl) expired in transit. Used for TraceRoute.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Ping.Status.TtlExpiredReassembly">
            <summary>
            The time to live (ttl) expired during fragment reassembly.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Ping.Status.ParameterProblem">
            <summary>
            A parameter problem.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Ping.Status.SourceQuench">
            <summary>
            Datagrams are arriving too fast to be processed and datagrams may have been dropped.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Ping.Status.OptionTooBig">
            <summary>
            An IP option was too big.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Ping.Status.BadDestination">
            <summary>
            A bad destination.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Ping.Status.Prohibited">
            <summary>
            Communication with destination administratively prohibited.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Ping.Status.GeneralFailure">
            <summary>
            A general failure indicating a malformed ICMP packet.
            </summary>
        </member>
        <member name="T:Dart.Sockets.PingThreadStart">
            <summary>
            Represents the method that will execute on a worker thread when <see cref="M:Dart.Sockets.Ping.Start(Dart.Sockets.PingThreadStart,System.Net.IPAddress,Dart.Sockets.Ping.Type,System.Object)">Start</see> is used. 
            </summary>
            <param name="slave">The PingSlave object that is independent of all other worker threads.</param>
            <param name="state">Any additional information provided by the user.</param>
        </member>
        <member name="T:Dart.Sockets.EchoEventArgs">
            <summary>
            Provides data for the Echo event.
            </summary>
        </member>
        <member name="F:Dart.Sockets.EchoEventArgs.Echoes">
            <summary>
            Gets the Echo result from the Ping.
            </summary>
        </member>
        <member name="T:Dart.Sockets.PingSlave">
            <summary>
            Used on each worker thread to provide a series of ICMP Echo (Ping) requests.
            </summary>
            <example>
        The following example demonstrates pinging a remote host.
        <code lang="C#">
        private void button1_Click(object sender, EventArgs e)
        {
            ping1.Start(pingWorker, HostNameOrAddressToPingTextbox.Text);
        }

        private void pingWorker(PingSlave slave, object state)
        {
            ping1.Marshal(slave.GetEchoes(new Dart.Sockets.IPEndPoint(state.ToString(), 0).Address, null, 20, 5000, false));
        }

        void ping1_Echo(object sender, EchoEventArgs e)
        {
            string results = "The following echoes were returned:\r\n";
            for (int i = 0; i &lt; e.Echoes.Length; i++)
                results += e.Echoes[i].ToString() + "\r\n";
            textBox1.AppendText(results);
        }
        </code><code lang="VB">
        Private Sub button1_Click(ByVal sender As Object, ByVal e As EventArgs)
            ping1.Start(AddressOf pingWorker, HostNameOrAddressToPingTextbox.Text)
        End Sub

        Private Sub pingWorker(ByVal slave As PingSlave, ByVal state As Object)
            ping1.Marshal(slave.GetEchoes((New Dart.Sockets.IPEndPoint(state.ToString(), 0)).Address, Nothing, 20, 5000, False))
        End Sub

        Private Sub ping1_Echo(ByVal sender As Object, ByVal e As EchoEventArgs)
            Dim results As String = "The following echoes were returned:" &amp; vbCrLf
            For i As Integer = 0 To e.Echoes.Length - 1
                results &amp;= e.Echoes(i).ToString() &amp; vbCrLf
            Next i
            textBox1.AppendText(results)
        End Sub
        </code></example>
        </member>
        <member name="M:Dart.Sockets.PingSlave.#ctor(System.Net.IPAddress,Dart.Sockets.Ping.Type)">
            <summary>
            Creates an object that manages ICMP Echo requests.
            </summary>
            <param name="localAddress">A IPAddress that establishes from which IP interface requests will originate.</param>
            <param name="type">Specifies what technology will be used to create the Echo request.</param>
            <remarks>The IPAddress.AddressFamily of the local EndPoint MUST match the AddressFamily of destination hosts.</remarks>
        </member>
        <member name="M:Dart.Sockets.PingSlave.GetEchoes(System.Net.IPAddress,System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Send an ICMP Echo request and block until all responses are received.
            </summary>
            <param name="address">The host where the Echo request is sent (can be a broadcast address).</param>
            <param name="data">The data to send in the Echo request. Can be null.</param>
            <param name="ttl">The maximum number of hops the request should take before expiring.</param>
            <param name="timeout">The number of milliseconds to wait for responses to arrive.</param>
            <param name="broadcast">If true, multiple socket receives will be used until the socket times out. 
            If false, only one socket receive is used.</param>
            <returns>One or more <see cref="T:Dart.Sockets.Echo" /> responses.</returns>
            <remarks>
                <para>This method will block until it times out while performing a socket receive.</para>
                <para>Ping broadcasting is supported when <see cref="F:Dart.Sockets.PingSlave.Type" /> is set to Type.Raw.
            When set to Type.System, only the first responding system is returned.</para>
            </remarks>
            <example>
        The following example demonstrates pinging a remote host.
        <code lang="C#">
        private void button1_Click(object sender, EventArgs e)
        {
            ping1.Start(pingWorker, HostNameOrAddressToPingTextbox.Text);
        }

        private void pingWorker(PingSlave slave, object state)
        {
            ping1.Marshal(slave.GetEchoes(new Dart.Sockets.IPEndPoint(state.ToString(), 0).Address, null, 20, 5000, false));
        }

        void ping1_Echo(object sender, EchoEventArgs e)
        {
            string results = "The following echoes were returned:\r\n";
            for (int i = 0; i &lt; e.Echoes.Length; i++)
                results += e.Echoes[i].ToString() + "\r\n";
            textBox1.AppendText(results);
        }
        </code><code lang="VB">
        Private Sub button1_Click(ByVal sender As Object, ByVal e As EventArgs)
            ping1.Start(AddressOf pingWorker, HostNameOrAddressToPingTextbox.Text)
        End Sub

        Private Sub pingWorker(ByVal slave As PingSlave, ByVal state As Object)
            ping1.Marshal(slave.GetEchoes((New Dart.Sockets.IPEndPoint(state.ToString(), 0)).Address, Nothing, 20, 5000, False))
        End Sub

        Private Sub ping1_Echo(ByVal sender As Object, ByVal e As EchoEventArgs)
            Dim results As String = "The following echoes were returned:" &amp; vbCrLf
            For i As Integer = 0 To e.Echoes.Length - 1
                results &amp;= e.Echoes(i).ToString() &amp; vbCrLf
            Next i
            textBox1.AppendText(results)
        End Sub
        </code></example>
        </member>
        <member name="T:Dart.Sockets.Echo">
            <summary>
            Encapsulates an echo response from a server.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Echo.RoundTripTime">
            <summary>
            Returns the time spanned between sending and receiving a response to the echo request.
            </summary>
            <value>
            A TimeSpan object.
            </value>
        </member>
        <member name="F:Dart.Sockets.Echo.Address">
            <summary>
            Returns the IP address of the remote host.
            </summary>
            <value>
            An IPAddress for the remote host.
            </value>
        </member>
        <member name="F:Dart.Sockets.Echo.Broadcast">
            <summary>
            Indicates whether Echo originated as an IPv4 broadcast request to address IPAddress.Broadcast (255.255.255.255).
            </summary>
        </member>
        <member name="F:Dart.Sockets.Echo.Data">
            <summary>
             Returns data returned from the echo request.
             </summary>
            <remarks>
                <para>
             When a ping request is sent, any data included in the packet is returned to the sender.
             </para>
            </remarks>
            <value>
             A byte array representing the data sent to and subsequently returned from the remote host.
            </value>
        </member>
        <member name="F:Dart.Sockets.Echo.Status">
            <summary>
            The status (success or otherwise) of the echo request.
            </summary>
        </member>
        <member name="F:Dart.Sockets.Echo.Ttl">
            <summary>
            Returns the TTL (time to live) for the packet.
            </summary>
            <remarks>
                <para>In practice TTL is decremented at each router the packet arrives at. 
            A packet with a TTL of 0 will be discarded.
            </para>
            </remarks>
            <value>
            Returns an integer value representing the TTL for the packet.
            </value>
        </member>
        <member name="M:Dart.Sockets.Echo.ToString">
            <summary>
            Returns a string containing information regarding the Echo.
            </summary>
            <returns>A string representing the echo.</returns>
        </member>
        <member name="T:Dart.Sockets.ProxyType">
            <summary>
            Enumerates the provided proxy support that can be used.
            </summary>
        </member>
        <member name="F:Dart.Sockets.ProxyType.None">
            <summary>
            No server proxy is to be used.
            </summary>
        </member>
        <member name="F:Dart.Sockets.ProxyType.Http">
            <summary>
            An HTTP server proxy is to be used.
            </summary>
        </member>
        <member name="F:Dart.Sockets.ProxyType.Socks4">
            <summary>
            A SOCKS4 server proxy is to be used.
            </summary>
        </member>
        <member name="F:Dart.Sockets.ProxyType.Socks5">
            <summary>
            A SOCKS5 server proxy is to be used.
            </summary>
        </member>
        <member name="T:Dart.Sockets.Proxy">
            <summary>
            Describes the server proxy, if any, to connect to.
            </summary>
        </member>
        <member name="M:Dart.Sockets.Proxy.#ctor">
            <summary>
            The default constructor for Proxy
            </summary>
        </member>
        <member name="P:Dart.Sockets.Proxy.RemoteEndPoint">
            <summary>
            IPEndPoint of the server proxy to connect to.
            </summary>
        </member>
        <member name="P:Dart.Sockets.Proxy.Password">
            <summary>
            The password to send to the server proxy. Not used for Socks4.
            </summary>
        </member>
        <member name="P:Dart.Sockets.Proxy.Type">
            <summary>
            The <see cref="T:Dart.Sockets.ProxyType" /> desired.
            </summary>
        </member>
        <member name="P:Dart.Sockets.Proxy.Username">
            <summary>
            The username to send to the server proxy.
            </summary>
        </member>
        <member name="T:Dart.Sockets.Security">
            <summary>
            Holds the configuration used to establish an SSL session.
            </summary>
        </member>
        <member name="M:Dart.Sockets.Security.#ctor">
            <summary>
            The default constructor for Security
            </summary>
        </member>
        <member name="F:Dart.Sockets.Security.ValidationCallback">
            <summary>
            The delegate that executes after the server provides its certificate to the client.
            </summary>
        </member>
        <member name="P:Dart.Sockets.Security.CheckCertificateRevocation">
            <summary>
            Indicates whether the certificate revocation list is checked during authentication.
            </summary>
        </member>
        <member name="P:Dart.Sockets.Security.Protocols">
            <summary>
            Gets or sets the SSL/TLS Protocols available for authentication.
            </summary>
            <remarks>
                <para>
            If 'None' is specified in .NET 4.7+ or .NET Core 2.0, the operating system will choose the best protocol to use during authentication, and block protocols that are not secure (with certain exceptions dependent upon the OS). 
            For more information, see the 'Security Protocol' section of the 'Security Implementation' top-level help topic.
            </para>
                <para>
            SSL2, SSL3, and Default should not be used due to their security vulnerabilities, and cannot be used in projects targeting .NET Core 2.0.
            </para>
            </remarks>
        </member>
        <member name="T:Dart.Sockets.ClientSecurity">
            <summary>
            Holds the configuration used to establish an SSL client session.
            </summary>
        </member>
        <member name="M:Dart.Sockets.ClientSecurity.#ctor">
            <summary>
            The default constructor for ClientSecurity
            </summary>
        </member>
        <member name="F:Dart.Sockets.ClientSecurity.SelectionCallback">
            <summary>
            The delegate that executes to permit selection of a cient certificate.
            </summary>
            <remarks>
                <para>If null, the <see cref="P:Dart.Sockets.ClientSecurity.Certificates" /> collection will be examined for a valid certifiate.</para>
                <para>The certificate returned in this delegate will supercede any certificate present in the <see cref="P:Dart.Sockets.ClientSecurity.Certificates" /> collection.</para>
            </remarks>
        </member>
        <member name="P:Dart.Sockets.ClientSecurity.Certificates">
            <summary>
            Gets or sets a collection of client certificates to use during authentication.
            </summary>
            <remarks>
                <para>If <see cref="F:Dart.Sockets.ClientSecurity.SelectionCallback" /> is not null, the certificate chosen in the delegate will supercede any certificate present in this collection.</para>
                <para>The first certificate in this collection that passes Microsoft's validation checks will be used during authentication.</para>
            </remarks>
        </member>
        <member name="P:Dart.Sockets.ClientSecurity.TargetHost">
            <summary>
            Gets or sets the remote host to be authenticated.
            </summary>
            <remarks>
                <para>Used internally as the first parameter for <see cref="M:System.Net.Security.SslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)">SslStream.AuthenticateAsClient()</see>, 
            it will typically match the common name of the server-side certificate. .NET also uses this value to maintain an internal cache of SSL sessions that can be re-used.</para>
                <para>If left empty, the value of the configured <see cref="P:Dart.Sockets.IPEndPoint.HostNameOrAddress">RemoteEndPoint.HostNameOrAddress</see> will be used for authentication when available.</para>
            </remarks>
        </member>
        <member name="T:Dart.Sockets.ServerSecurity">
            <summary>
            Holds the configuration used to establish an SSL server session.
            </summary>
        </member>
        <member name="M:Dart.Sockets.ServerSecurity.#ctor">
            <summary>
            The default constructor for ServerSecurity
            </summary>
        </member>
        <member name="P:Dart.Sockets.ServerSecurity.RequireClientCertificate">
            <summary>
            Indicates whether the server requires a client certificate.
            </summary>
        </member>
        <member name="P:Dart.Sockets.ServerSecurity.Certificate">
            <summary>
            Gets or sets the server certificate to provide the client.
            </summary>
        </member>
        <member name="T:Dart.Sockets.Server">
            <summary>
            The Server component provides a framework for building non-secure and secure server applications.
            </summary>
            <remarks>
                <para> Use the Server component to listen for incoming connections. When a connection is
            established from a TCP client, a new thread is created on which the server and client communicate. </para>
                <para>What follows are short usage descriptions. For more information, see the appropriate member topic.</para>
                <H4 class="dtH4">Using the Server Component</H4>
                <para>
                    <b>Listening for connections:</b> Use Server.Start (specifying the port to listen on) to listen for incoming 
            TCP connections.</para>
                <para>
                    <b>Determining if the server is active:</b> The Socket property is non-null when the server is active.</para>
                <para>
                    <b>Handling incoming connections:</b> When a TCP client connects to the server, a user-specified delegate is raised. 
            A Tcp object is provided to the delegate, representing the client/server connection.
            Use the Tcp object to send and receive data to/from the connected client (both synchronous and asynchronous operation 
            is supported). To facilitate memory release, dispose of the object and call GC.Collect when the connection is terminated.</para>
                <para>
                    <b>Stop accepting incoming connections:</b> Use <see cref="M:Dart.Sockets.Server.Close" /> to stop accepting incoming connections. 
            Any existing connections will complete normally.</para>
                <para>
                    <b>Stop the server and close all connections: </b> Use <see cref="M:Dart.Sockets.Server.Abort" />.</para>
                <para>
                    <b>Communicating securely:</b> Call <see cref="M:Dart.Sockets.TcpBase.AuthenticateAsServer(Dart.Sockets.ServerSecurity)" /> for each incoming connection.
            </para>
            </remarks>
            <example>
        The following example demonstrates an echo server using asynchronous read and write methods that utilize IO completion ports.
        <code lang="C#">
        private void button1_Click(object sender, EventArgs e)
        {
            //Start the echo server on port 7
            server1.Start(server1_NewConnection, 7, null);
        }

        private void server1_NewConnection(Tcp client, object state)
        {
            //Read first data sent by client
            byte[] buffer = new byte[1024];
            client.ReadAsync(buffer, 0, buffer.Length, client_ReadAsyncCompleted, null);
        }

        private void client_ReadAsyncCompleted(TcpBase client, Data data, Exception ex, object state)
        {
            //Echo data received back to client.
            //Data is null if client is not connected.
            if (data != null)
                client.WriteAsync(data.Buffer, data.Offset, data.Count, client_WriteAsyncCompleted, null);
        }

        private void client_WriteAsyncCompleted(TcpBase client, Data data, Exception ex, object state)
        {
            //Read for more data.
            client.ReadAsync(data.Buffer, 0, data.Buffer.Length, client_ReadAsyncCompleted, null);
        }
        </code><code lang="VB">
        Private Sub button1_Click(ByVal sender As Object, ByVal e As EventArgs)
            'Start the echo server on port 7
            server1.Start(AddressOf server1_NewConnection, 7, Nothing)
        End Sub

        Private Sub server1_NewConnection(ByVal client As Tcp, ByVal state As Object)
            'Read first data sent by client
            Dim buffer(1023) As Byte
            client.ReadAsync(buffer, 0, buffer.Length, AddressOf client_ReadAsyncCompleted, Nothing)
        End Sub

        Private Sub client_ReadAsyncCompleted(ByVal client As TcpBase, ByVal data As Data, ByVal ex As Exception, ByVal state As Object)
            'Echo data received back to client.
            'Data is null if client is not connected.
            If data IsNot Nothing Then
                client.WriteAsync(data.Buffer, data.Offset, data.Count, AddressOf client_WriteAsyncCompleted, Nothing)
            End If
        End Sub

        Private Sub client_WriteAsyncCompleted(ByVal client As TcpBase, ByVal data As Data, ByVal ex As Exception, ByVal state As Object)
            'Read for more data.
            client.ReadAsync(data.Buffer, 0, data.Buffer.Length, AddressOf client_ReadAsyncCompleted, Nothing)
        End Sub
        </code></example>
            <example>
        The following example demonstrates an echo server on a single thread.
        <code lang="C#">
        private void button1_Click(object sender, EventArgs e)
        {
            //Start the echo server on port 7
            server1.Start(server1_NewConnection, 7, null);
        }

        private void server1_NewConnection(Tcp client, object state)
        {
            //While connection is open, read and echo data back to client
            byte[] buffer = new byte[1024];
            Data data = client.Read(buffer);
            while (data != null)
            {
                client.Write(data.Buffer, data.Offset, data.Count);
                data = client.Read(buffer);
            }
        }
        </code><code lang="VB">
        Private Sub button1_Click(ByVal sender As Object, ByVal e As EventArgs)
            'Start the echo server on port 7
            server1.Start(AddressOf server1_NewConnection, 7, Nothing)
        End Sub

        Private Sub server1_NewConnection(ByVal client As Tcp, ByVal state As Object)
            'While connection is open, read and echo data back to client
            Dim buffer(1023) As Byte
            Dim data As Data = client.Read(buffer)
            Do While data IsNot Nothing
                client.Write(data.Buffer, data.Offset, data.Count)
                data = client.Read(buffer)
            Loop
        End Sub
        </code></example>
        </member>
        <member name="M:Dart.Sockets.Server.#ctor(System.ComponentModel.IContainer)">
            <summary>
            Initializes a new Server object.
            </summary>
            <param name="container">The IContainer which contains the object.</param>
        </member>
        <member name="M:Dart.Sockets.Server.#ctor">
            <summary>
            Initializes a new Server.
            </summary>
            <remarks>
            The default constructor dynamically initializes a new Server class.
            </remarks>
        </member>
        <member name="M:Dart.Sockets.Server.Dispose(System.Boolean)">
            <summary>
            Releases all resources associated with the object.
            </summary>
            <param name="disposing">true when a user calls Dispose; false when called by a finalizer.</param>
        </member>
        <member name="F:Dart.Sockets.Server.Connections">
            <summary>
            Returns a List of Tcp objects representing active connections.
            </summary>
            <remarks>
                <para>
            When a client connects to the server, a Tcp object representing
            the connection is added to <see cref="F:Dart.Sockets.Server.Connections" /> and the ConnectionsChanged event is raised. 
            When the connection
            is closed, the connection is removed from Connections and the ConnectionsChanged event is raised again.
            </para>
                <para>
            Accessing the Connections collection is not thread-safe. Use "lock(server1.Connections)" (C# syntax) to ensure thread safety.
            </para>
            </remarks>
        </member>
        <member name="M:Dart.Sockets.Server.Abort">
            <summary>
            Closes the listening socket and calls Close() on each active connection.
            </summary>
        </member>
        <member name="M:Dart.Sockets.Server.Close">
            <summary>
            Closes the listening socket and allows each active connection to complete normally.
            </summary>
        </member>
        <member name="M:Dart.Sockets.Server.Start(Dart.Sockets.ConnectThreadStart,System.Int32,System.Object)">
            <summary>
            Begin listening on the specified port on all IPv4 network interfaces.
            </summary>
            <param name="callback">A <see cref="T:Dart.Sockets.ConnectThreadStart" /> delegate referencing the method to invoke on an IO completion thread as each connection is accepted.</param>
            <param name="localPort">Local port to bind to.</param>
            <param name="state">Object to pass into the callback method when invoked; can be null.</param>
            <remarks>
            This method does not block. Connections are accepted on IO completion threads and are reported to the specified delegate.
            </remarks>
            <example>
        The following example demonstrates an echo server using asynchronous read and write methods that utilize IO completion ports.
        <code lang="C#">
        private void button1_Click(object sender, EventArgs e)
        {
            //Start the echo server on port 7
            server1.Start(server1_NewConnection, 7, null);
        }

        private void server1_NewConnection(Tcp client, object state)
        {
            //Read first data sent by client
            byte[] buffer = new byte[1024];
            client.ReadAsync(buffer, 0, buffer.Length, client_ReadAsyncCompleted, null);
        }

        private void client_ReadAsyncCompleted(TcpBase client, Data data, Exception ex, object state)
        {
            //Echo data received back to client.
            //Data is null if client is not connected.
            if (data != null)
                client.WriteAsync(data.Buffer, data.Offset, data.Count, client_WriteAsyncCompleted, null);
        }

        private void client_WriteAsyncCompleted(TcpBase client, Data data, Exception ex, object state)
        {
            //Read for more data.
            client.ReadAsync(data.Buffer, 0, data.Buffer.Length, client_ReadAsyncCompleted, null);
        }
        </code><code lang="VB">
        Private Sub button1_Click(ByVal sender As Object, ByVal e As EventArgs)
            'Start the echo server on port 7
            server1.Start(AddressOf server1_NewConnection, 7, Nothing)
        End Sub

        Private Sub server1_NewConnection(ByVal client As Tcp, ByVal state As Object)
            'Read first data sent by client
            Dim buffer(1023) As Byte
            client.ReadAsync(buffer, 0, buffer.Length, AddressOf client_ReadAsyncCompleted, Nothing)
        End Sub

        Private Sub client_ReadAsyncCompleted(ByVal client As TcpBase, ByVal data As Data, ByVal ex As Exception, ByVal state As Object)
            'Echo data received back to client.
            'Data is null if client is not connected.
            If data IsNot Nothing Then
                client.WriteAsync(data.Buffer, data.Offset, data.Count, AddressOf client_WriteAsyncCompleted, Nothing)
            End If
        End Sub

        Private Sub client_WriteAsyncCompleted(ByVal client As TcpBase, ByVal data As Data, ByVal ex As Exception, ByVal state As Object)
            'Read for more data.
            client.ReadAsync(data.Buffer, 0, data.Buffer.Length, AddressOf client_ReadAsyncCompleted, Nothing)
        End Sub
        </code></example>
        </member>
        <member name="M:Dart.Sockets.Server.Start(Dart.Sockets.ConnectThreadStart,System.Net.IPEndPoint,System.Object)">
            <summary>
            Begin listening on the specified IPEndPoint.
            </summary>
            <param name="callback">A <see cref="T:Dart.Sockets.ConnectThreadStart" /> delegate referencing the method to invoke on an IO completion thread as each connection is accepted.</param>
            <param name="localEP">Local endpoint to bind to.</param>
            <param name="state">Object to pass into the callback method when invoked; can be null.</param>
            <remarks>
            This method does not block. Connections are accepted on IO completion threads and are reported to the specified delegate.
            </remarks>
        </member>
        <member name="M:Dart.Sockets.Server.OnConnectionsChanged(Dart.Sockets.ConnectionsChangedEventArgs)">
            <summary>
            Raises the <see cref="E:Dart.Sockets.Server.ConnectionsChanged" /> event.
            </summary>
            <remarks>
                <para>
            If the Synchronizing property is set, this method asynchronously invokes the <see cref="E:Dart.Sockets.Server.ConnectionsChanged" /> event on the UI thread.
            If the Synchronizing property is null, this method invokes the event on the executing thread.
            </para>
                <para>
            This method allows derived classes to handle the event without attaching a delegate, but marshaling is not provided.
            This is the preferred technique for handling the event in a derived class.
            </para>
                <para>
                    <b>Note to Inheritors:</b> When overriding OnConnectionsChanged in a derived class, 
            be sure to call the base class OnConnectionsChanged method, so that registered delegates receive the event. 
            </para>
                <para>
            See the <see cref="P:Dart.Sockets.ComponentBase.SynchronizingObject">SynchronizingObject</see> property for information on 
            updating UI controls in your event handler.
            </para>
            </remarks>
        </member>
        <member name="P:Dart.Sockets.Server.Backlog">
            <summary>
            The maximum length of the pending connections queue.
            </summary>
            <remarks>This value is used as a parameter to the <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)">Socket.Listen</see> method.</remarks>
        </member>
        <member name="E:Dart.Sockets.Server.ConnectionsChanged">
            <summary>
            Raised after the <see cref="F:Dart.Sockets.Server.Connections" /> list has changed.
            </summary>
            <remarks>
                <para>
                This event is raised on the UI thread so that data can be used with UI components.
                </para>
                <para>
                See <see cref="P:Dart.Sockets.ComponentBase.SynchronizingObject">SynchronizingObject</see> for important information on updating UI controls
                from within this event.
                </para>
            </remarks>
        </member>
        <member name="T:Dart.Sockets.ConnectionsChangedEventArgs">
            <summary>
            Provides data for the ConnectionsChanged event.
            </summary>
        </member>
        <member name="M:Dart.Sockets.ConnectionsChangedEventArgs.#ctor(Dart.Sockets.Tcp)">
            <summary>
            Initializes a new ConnectionsChangedEventArgs.
            </summary>
        </member>
        <member name="P:Dart.Sockets.ConnectionsChangedEventArgs.Connection">
            <summary>
            Gets the Tcp object provided by the <see cref="E:Dart.Sockets.Server.ConnectionsChanged">ConnectionsChanged</see> event.
            </summary>
        </member>
        <member name="T:Dart.Sockets.ConnectThreadStart">
            <summary>
            Represents the method that will execute on a worker thread after each TCP connection is accepted. 
            </summary>
            <param name="tcp">The Tcp object used to manage the accepted connection.</param>
            <param name="state">Any additional information provided by the user.</param>
        </member>
        <member name="T:Dart.Sockets.strings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="T:Dart.Sockets.Tcp">
            <summary>
            The Tcp component simplifies the use of secure Tcp communications within any .NET application.
            </summary>
            <remarks>
                <para>
                The Tcp component establishes and manages TCP-level streams of data. 
                Methods for establishing connections, and sending and receiving data simplify 
                Tcp communications for the user, while still providing options for advanced customization.
                Secure SSL connections and worker thread operation are fully supported.
                </para>
                <para>
                The Tcp component can optionally be bound to a display control for easy user-interactive development.
                </para>
                <H4 class="dtH4">Using the Tcp Component</H4>
                <para>
                The Tcp component's clean interface provides clear, straight-forward use.
                All methods calls are blocking calls, making programming an intuitive step-by-step process.
                Functions can be passed to the <see cref="M:Dart.Sockets.Tcp.Start(System.Threading.WaitCallback,System.Object)">Start</see> method, to execute on worker threads without
                blocking the user interface.
                Marshaling data from these worker threads is made convenient using the overloaded Marshal methods. 
                See the Asynchronous Operation page for more information on this topic.
                </para>
                <ul>
                    <li>
                        <para>
                            <b>Connecting:</b> Use the 
                <see cref="M:Dart.Sockets.TcpBase.Connect(Dart.Sockets.TcpSession)">Connect</see> method.
                Once connected, establish an optional secure connection using 
                <see cref="M:Dart.Sockets.TcpBase.AuthenticateAsClient(Dart.Sockets.ClientSecurity)">AuthenticateAsClient</see>.
                </para>
                    </li>
                    <li>
                        <para>
                            <b>Sending Data:</b>
                Once a connection is established, send data using the <see cref="M:Dart.Sockets.TcpBase.Write(System.Byte[],System.Int32,System.Int32)">Write</see> method, 
                which includes overloads for sending data as byte arrays or as strings.
                </para>
                    </li>
                    <li>
                        <para>
                            <b>Receiving Data:</b>
                Receive data using the <see cref="M:Dart.Sockets.TcpBase.Read(System.Byte[],System.Int32,System.Int32)">Read</see> method.
                This method returns a <see cref="T:Dart.Sockets.Data">Data</see> object containing data read off the data stream.  
                Data in this object can easily be converted to a string using its <see cref="M:Dart.Sockets.Data.ToString">ToString</see> method.
                The Read method includes overloads for reading until a specified delimiter is found.
                A set of delimiters can also be specified for situations in which one of several responses may be received.  
                Marshal data to the <see cref="E:Dart.Sockets.TcpBase.Data">Data</see> event (on the UI thread) by calling the Marshal method.
                </para>
                    </li>
                </ul>
                <H4 class="dtH4">Binding the Tcp Component to a Display</H4>
                <para>
                Set the <see cref="P:Dart.Sockets.PtyBase.Pty">Pty</see> (pseudo terminal) property to bind the Telnet component to a display control 
                derived from <see cref="T:System.Windows.Forms.TextBoxBase">TextBoxBase</see> 
                (such as a standard <see cref="T:System.Windows.Forms.TextBox">TextBox</see>), 
                and call <see cref="M:Dart.Sockets.TcpBase.Connect(Dart.Sockets.TcpSession)">Connect</see> to establish a connection to the specified host.  
                Once connected, keystrokes will be sent automatically, and data received will appear in the text area. 
                </para>
            </remarks>
            <example>
        The following example demonstrates simple Tcp read and write operations on a worker thread, and marshaling the received data to the main thread.
        <code lang="C#">
        private void button1_Click(object sender, EventArgs e)
        {
            tcp1.Start(connectWriteRead, null);
        }

        private void connectWriteRead(object state)
        {
            tcp1.Connect(new TcpSession(new Dart.Sockets.IPEndPoint(myEchoServer, 7)));
            tcp1.Write("hello world!");
            byte[] buffer = new byte[128];
            tcp1.Marshal(tcp1.Read(buffer), "", null);
            tcp1.Close();
        }

        void tcp1_Data(object sender, Dart.Sockets.DataEventArgs e)
        {
            textBox1.AppendText(e.Data.ToString());
        }
        </code><code lang="VB">
        Private Sub button1_Click(ByVal sender As Object, ByVal e As EventArgs)
            tcp1.Start(AddressOf connectWriteRead, Nothing)
        End Sub

        Private Sub connectWriteRead(ByVal state As Object)
            tcp1.Connect(New TcpSession(New Dart.Sockets.IPEndPoint(myEchoServer, 7)))
            tcp1.Write("hello world!")
            Dim buffer(127) As Byte
            tcp1.Marshal(tcp1.Read(buffer), "", Nothing)
            tcp1.Close()
        End Sub

        Private Sub tcp1_Data(ByVal sender As Object, ByVal e As Dart.Sockets.DataEventArgs)
            textBox1.AppendText(e.Data.ToString())
        End Sub
        </code></example>
        </member>
        <member name="M:Dart.Sockets.Tcp.#ctor">
            <summary>
            Initializes a new instance of the Tcp component.
            </summary>
        </member>
        <member name="M:Dart.Sockets.Tcp.#ctor(System.ComponentModel.IContainer)">
            <summary>
            Initializes a new Tcp object.
            </summary>
            <param name="container">The IContainer which contains the object.</param>
        </member>
        <member name="M:Dart.Sockets.Tcp.#ctor(System.Net.Sockets.Socket)">
            <summary>
            Create a Tcp object from an accepted <see cref="T:System.Net.Sockets.Socket" />.
            </summary>
            <param name="acceptedSocket">An existing Socket.</param>
        </member>
        <member name="M:Dart.Sockets.Tcp.Start(System.Threading.WaitCallback,System.Object)">
            <summary>
            Start a worker thread on which the specified delegate function executes.  
            </summary>
            <param name="worker">
                <see cref="T:System.Threading.WaitCallback" /> delegate specifying the function to execute.</param>
            <param name="state">Information to pass to the worker delegate method; can be null.</param>
            <remarks>
                <para>
                This method provides an easy means for executing blocking functions on a worker thread. 
                Applications with a UI thread should use this technique to execute processes (like Connect and Read) 
                that can block the UI thread.
                </para>
                <para>
                Unhandled exceptions occurring on the worker thread will be caught and reported by the 
                <see cref="E:Dart.Sockets.ComponentBase.Error">Error</see> event.
                </para>
            </remarks>
            <example>
        The following example demonstrates simple Tcp read and write operations on a worker thread, and marshaling the received data to the main thread.
        <code lang="C#">
        private void button1_Click(object sender, EventArgs e)
        {
            tcp1.Start(connectWriteRead, null);
        }

        private void connectWriteRead(object state)
        {
            tcp1.Connect(new TcpSession(new Dart.Sockets.IPEndPoint(myEchoServer, 7)));
            tcp1.Write("hello world!");
            byte[] buffer = new byte[128];
            tcp1.Marshal(tcp1.Read(buffer), "", null);
            tcp1.Close();
        }

        void tcp1_Data(object sender, Dart.Sockets.DataEventArgs e)
        {
            textBox1.AppendText(e.Data.ToString());
        }
        </code><code lang="VB">
        Private Sub button1_Click(ByVal sender As Object, ByVal e As EventArgs)
            tcp1.Start(AddressOf connectWriteRead, Nothing)
        End Sub

        Private Sub connectWriteRead(ByVal state As Object)
            tcp1.Connect(New TcpSession(New Dart.Sockets.IPEndPoint(myEchoServer, 7)))
            tcp1.Write("hello world!")
            Dim buffer(127) As Byte
            tcp1.Marshal(tcp1.Read(buffer), "", Nothing)
            tcp1.Close()
        End Sub

        Private Sub tcp1_Data(ByVal sender As Object, ByVal e As Dart.Sockets.DataEventArgs)
            textBox1.AppendText(e.Data.ToString())
        End Sub
        </code></example>
        </member>
        <member name="T:Dart.Sockets.Udp">
            <summary>
            The Udp component provides comprehensive User Datagram Protocol support.
            </summary>
            <remarks>
                <para>Use the Udp component to send and receive UDP datagrams.</para>
                <para>Use the <see cref="M:Dart.Sockets.UdpBase.Open(System.Int32)" /> method to bind to a socket prior to sending and receiving.</para>
                <para>Use the <see cref="M:Dart.Sockets.UdpBase.Send(System.Byte[],System.Net.IPEndPoint)" /> and 
            <see cref="M:Dart.Sockets.UdpBase.Receive(System.Byte[])" /> methods to send/receive datagrams.</para>
                <para>Use <see cref="M:Dart.Sockets.UdpBase.JoinMulticastGroup(System.Net.IPAddress)" /> to join a multicast group, 
            and <see cref="M:Dart.Sockets.UdpBase.LeaveMulticastGroup(System.Net.IPAddress)" /> to leave a multicast group.</para>
                <para>Use <see cref="M:Dart.Sockets.Udp.Start(System.Threading.WaitCallback,System.Object)" /> to send or receive datagrams asynchronously, on a worker thread.</para>
            </remarks>
            <example>
        The following example demonstrates sending and receiving between two Udp components.
        <code lang="C#">
        private void buttonStartServer_Click(object sender, EventArgs e)
        {
            //Start worker thread to bind to the socket and start echoing data.
            udpServer.Start(udpServer_Open, null);
        }

        private void buttonStopServer_Click(object sender, EventArgs e)
        { 
            udpServer.Close();
        }

        private void buttonDoEcho_Click(object sender, EventArgs e)
        {
            //Start a Udp component to act as client
            udpClient.Start(udpClient_DoEcho, null);
        }

        private void udpServer_Open(object state)
        {
            byte[] buffer = new byte[1024];
            udpServer.Open(7);
            Datagram datagram = udpServer.Receive(buffer);
            //Datagram is null when local socket has been closed
            while (datagram != null)
            {
                if (datagram.Count &gt; 0)
                    udpServer.Send(buffer, datagram.Origin);
                datagram = udpServer.Receive(buffer);
            }
        }

        private void udpClient_DoEcho(object state)
        {
            //Send message, receive response and close
            byte[] buffer = new byte[1024];
            udpClient.Open(0);
            udpClient.Send("hello world!", "127.0.0.1", 7);
            Datagram datagram = udpClient.Receive(buffer);
            //marshal data to UI thread
            udpClient.Marshal(datagram.ToString(), null);
            udpClient.Close();
        }

        private void udpClient_UserState(object sender, UserStateEventArgs e)
        {
            textBox1.AppendText(e.Message);
        }
        </code><code lang="VB">
        Private Sub buttonStartServer_Click(ByVal sender As Object, ByVal e As EventArgs)
            'Start worker thread to bind to the socket and start echoing data.
            udpServer.Start(AddressOf udpServer_Open, Nothing)
        End Sub

        Private Sub buttonStopServer_Click(ByVal sender As Object, ByVal e As EventArgs)
            udpServer.Close()
        End Sub

        Private Sub buttonDoEcho_Click(ByVal sender As Object, ByVal e As EventArgs) Handles buttonDoEcho.Click
            'Start a Udp component to act as client
            udpClient.Start(AddressOf udpClient_DoEcho, Nothing)
        End Sub

        Private Sub udpServer_Open(ByVal state As Object)
            Dim buffer(1023) As Byte
            udpServer.Open(7)
            Dim datagram As Datagram = udpServer.Receive(buffer)
            'Datagram is null when local socket has been closed
            Do While datagram IsNot Nothing
                If datagram.Count &gt; 0 Then
                    udpServer.Send(buffer, datagram.Origin)
                End If
                datagram = udpServer.Receive(buffer)
            Loop
        End Sub

        Private Sub udpClient_DoEcho(ByVal state As Object)
            'Send message, receive response and close
            Dim buffer(1023) As Byte
            udpClient.Open(0)
            udpClient.Send("hello world!", "127.0.0.1", 7)
            Dim datagram As Datagram = udpClient.Receive(buffer)
            'marshal data to UI thread
            udpClient.Marshal(datagram.ToString(), Nothing)
            udpClient.Close()
        End Sub

        Private Sub udpClient_UserState(ByVal sender As Object, ByVal e As UserStateEventArgs)
            textBox1.AppendText(e.Message)
        End Sub
        </code></example>
            <example>
        The following example demonstrates joining a multicast group, sending data to it, receiving that data, and leaving the multicast group.
        <code lang="C#">
        private void button1_Click(object sender, EventArgs e)
        {
            udp1.Start(multicastWorker, null);
        }

        private void multicastWorker(object state)
        {
            IPEndPoint groupEndPoint = new IPEndPoint("239.0.0.1", 32000);
            udp1.Open(32000);
            udp1.JoinMulticastGroup(groupEndPoint.Address);
            udp1.Send("hello world!", groupEndPoint);
            byte[] buffer = new byte[1024];
            Datagram datagram = udp1.Receive(buffer);
            //Marshal data to UI for display
            udp1.Marshal(datagram.ToString(), null);
            udp1.LeaveMulticastGroup(groupEndPoint.Address);
            udp1.Close();
        }

        void udp1_UserState(object sender, UserStateEventArgs e)
        {
            textBox1.AppendText(e.Message);
        }
        </code><code lang="VB">
        Private Sub button1_Click(ByVal sender As Object, ByVal e As EventArgs) Handles button1.Click
            udp1.Start(AddressOf multicastWorker, Nothing)
        End Sub

        Private Sub multicastWorker(ByVal state As Object)
            Dim groupEndPoint As New IPEndPoint("239.0.0.1", 32000)
            udp1.Open(32000)
            udp1.JoinMulticastGroup(groupEndPoint.Address)
            udp1.Send("hello world!", groupEndPoint)
            Dim buffer(1023) As Byte
            Dim datagram As Datagram = udp1.Receive(buffer)
            'Marshal data to UI for display
            udp1.Marshal(datagram.ToString(), Nothing)
            udp1.LeaveMulticastGroup(groupEndPoint.Address)
            udp1.Close()
        End Sub

        Private Sub udp1_UserState(ByVal sender As Object, ByVal e As UserStateEventArgs)
            textBox1.AppendText(e.Message)
        End Sub
        </code></example>
        </member>
        <member name="M:Dart.Sockets.Udp.#ctor">
            <summary>
            Initializes a new Udp object.
            </summary>
            <remarks>
                <para>The default constructor initializes a new Udp object.</para>
            </remarks>
        </member>
        <member name="M:Dart.Sockets.Udp.#ctor(System.ComponentModel.IContainer)">
            <summary>
            Initializes a new Udp object.
            </summary>
            <param name="container">The IContainer which contains the object.</param>
        </member>
        <member name="M:Dart.Sockets.Udp.Dispose(System.Boolean)">
            <summary>
            Releases all resources associated with the object.
            </summary>
            <param name="disposing">true when a user calls Dispose; false when called by a finalizer.</param>
        </member>
        <member name="M:Dart.Sockets.Udp.Start(System.Threading.WaitCallback,System.Object)">
            <summary>
            Starts a worker thread on which the specified delegate method executes.  
            </summary>
            <param name="worker">
                <see cref="T:System.Threading.WaitCallback" /> delegate specifying the function to execute.</param>
            <param name="state">Information to pass to the worker delegate function; can be null.</param>
            <remarks>
                <para>
                This method provides an easy means for executing blocking functions on a worker thread. 
                Applications with a UI thread should use this technique to execute processes (like Receive) that can block the UI thread.
                </para>
                <para>
                The <i>state</i> parameter can be <b>null</b> for cases in which no state information needs to be passed to the worker delegate function.
                </para>
                <para>
                Unhandled exceptions occurring on the worker thread will be caught and reported by the <see cref="E:Dart.Sockets.ComponentBase.Error">Error</see> event.
                </para>
            </remarks>
            <example>
        The following example demonstrates sending and receiving between two Udp components.
        <code lang="C#">
        private void buttonStartServer_Click(object sender, EventArgs e)
        {
            //Start worker thread to bind to the socket and start echoing data.
            udpServer.Start(udpServer_Open, null);
        }

        private void buttonStopServer_Click(object sender, EventArgs e)
        { 
            udpServer.Close();
        }

        private void buttonDoEcho_Click(object sender, EventArgs e)
        {
            //Start a Udp component to act as client
            udpClient.Start(udpClient_DoEcho, null);
        }

        private void udpServer_Open(object state)
        {
            byte[] buffer = new byte[1024];
            udpServer.Open(7);
            Datagram datagram = udpServer.Receive(buffer);
            //Datagram is null when local socket has been closed
            while (datagram != null)
            {
                if (datagram.Count &gt; 0)
                    udpServer.Send(buffer, datagram.Origin);
                datagram = udpServer.Receive(buffer);
            }
        }

        private void udpClient_DoEcho(object state)
        {
            //Send message, receive response and close
            byte[] buffer = new byte[1024];
            udpClient.Open(0);
            udpClient.Send("hello world!", "127.0.0.1", 7);
            Datagram datagram = udpClient.Receive(buffer);
            //marshal data to UI thread
            udpClient.Marshal(datagram.ToString(), null);
            udpClient.Close();
        }

        private void udpClient_UserState(object sender, UserStateEventArgs e)
        {
            textBox1.AppendText(e.Message);
        }
        </code><code lang="VB">
        Private Sub buttonStartServer_Click(ByVal sender As Object, ByVal e As EventArgs)
            'Start worker thread to bind to the socket and start echoing data.
            udpServer.Start(AddressOf udpServer_Open, Nothing)
        End Sub

        Private Sub buttonStopServer_Click(ByVal sender As Object, ByVal e As EventArgs)
            udpServer.Close()
        End Sub

        Private Sub buttonDoEcho_Click(ByVal sender As Object, ByVal e As EventArgs) Handles buttonDoEcho.Click
            'Start a Udp component to act as client
            udpClient.Start(AddressOf udpClient_DoEcho, Nothing)
        End Sub

        Private Sub udpServer_Open(ByVal state As Object)
            Dim buffer(1023) As Byte
            udpServer.Open(7)
            Dim datagram As Datagram = udpServer.Receive(buffer)
            'Datagram is null when local socket has been closed
            Do While datagram IsNot Nothing
                If datagram.Count &gt; 0 Then
                    udpServer.Send(buffer, datagram.Origin)
                End If
                datagram = udpServer.Receive(buffer)
            Loop
        End Sub

        Private Sub udpClient_DoEcho(ByVal state As Object)
            'Send message, receive response and close
            Dim buffer(1023) As Byte
            udpClient.Open(0)
            udpClient.Send("hello world!", "127.0.0.1", 7)
            Dim datagram As Datagram = udpClient.Receive(buffer)
            'marshal data to UI thread
            udpClient.Marshal(datagram.ToString(), Nothing)
            udpClient.Close()
        End Sub

        Private Sub udpClient_UserState(ByVal sender As Object, ByVal e As UserStateEventArgs)
            textBox1.AppendText(e.Message)
        End Sub
        </code></example>
        </member>
    </members>
</doc>